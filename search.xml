<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>开发小记——Web Audio API</title>
      <link href="/2020/04/%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94Web-Audio-API/"/>
      <url>/2020/04/%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0%E2%80%94%E2%80%94Web-Audio-API/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>最近在做一个在线语音聊天室的项目，在此之前零经验，所以疯狂爬帖。对于 Web Audio API 来说，除了 MDN 之外，资料不是特别多，<a href="https://juejin.im/" target="_blank" rel="noopener" title="主页">掘金</a> 和 <a href="https://segmentfault.com/" target="_blank" rel="noopener" title="主页">思否</a> 文章相对集中，但也不全是新的，这就导致了一个刚入手就会遇到的坑。</p><blockquote><p>本文重点不是介绍 Web Audio API，而是分享开发时的历程。若想获得更多知识以及技术细节，请参阅 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank" rel="noopener" title="Web Audio API - MDN">MDN</a> 和文末 <a href="#%E6%8E%A8%E8%8D%90%E9%98%85%E8%AF%BB">推荐阅读</a> 中的文章。</p></blockquote><p>测试环境：</p><ul><li>Mozilla Firefox：v75.0</li><li>Microsoft Edge：v81.0.416.64</li></ul><h2 id="getusermedia"><a class="markdownIt-Anchor" href="#getusermedia"></a> getUserMedia</h2><p>使用 Web Audio API 进行录音，第一步就是要拿到浏览器的录音 API 以及获得相应的录音权限，部分文章会使用 <code>navigator.getUserMedia()</code> 这个 API。为解决不同浏览器兼容性问题，有形如以下的代码：</p><pre class="highlight"><code class="js">navigator.getUserMedia =navigator.getUserMedia ||navigator.webkitGetUserMedia ||navigator.mozGetUserMedia ||navigator.msGetUserMedia;navigator.getUserMedia(constraints, sucCallBack, errCallBack);</code></pre><p>上述代码是在三四年前（当前 2020 年）的历史条件下形成的，在 Firefox 下运行可能会有以下警告⚠️：</p><p><img src="https://s1.ax1x.com/2020/04/28/J42AqU.png" alt="#b# getUserMedia() 的警告" /></p><p>访问 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/getUserMedia" target="_blank" rel="noopener" title="Navigator.getUserMedia - MDN">MDN 对应页面</a>，可以看到该 API 被 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices/getUserMedia" target="_blank" rel="noopener" title="MediaDevices.getUserMedia - MDN"><code>MediaDevices.getUserMedia()</code></a> 取代，并且结合了 Promise。作为 Navigator 的一个子对象，调用形式如下：</p><pre class="highlight"><code class="js">navigator.mediaDevices.getUserMedia({ <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">video</span>: <span class="hljs-literal">false</span> });.then(<span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {<span class="hljs-comment">/* 使用 stream */</span>}).catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {<span class="hljs-comment">/* 处理 error */</span>});</code></pre><p>使用 Promise 的 <code>then()</code> resolve <code>sucCallBack()</code> 处理成功的回调，<code>catch()</code> reject <code>errCallBack()</code> 处理失败的回调，<code>constraints</code> 照旧。</p><blockquote><p>返回一个 Promise 对象，成功后会 resolve 回调一个 MediaStream 对象。若用户拒绝了使用权限，或者需要的媒体源不可用，promise 会 reject 回调一个 <code>PermissionDeniedError</code> 或者 <code>NotFoundError</code>。</p></blockquote><blockquote><p>返回的 promise 对象可能既不会 resolve 也不会 reject，因为用户不是必须选择允许或拒绝。</p></blockquote><p>版本问题不能算是坑，毕竟要考虑项目的用户对象等各种原因，但对于一个刚入坑的新人来讲，很容易摸不着头脑，不知孰对孰错。</p><p>好，通过 <code>navigator.mediaDevices.getUserMedia()</code> 指定的 resolve 函数，现在可以得到 <code>stream</code> 了，这是一个 MediaStream 媒体流，可以直接作为音频或视频的播放源。那么，如何播放呢？创建 <code>&lt;audio&gt;</code> 或者 <code>&lt;video&gt;</code> 标签，填写 <code>src</code> 属性然后触发响应事件就行，OK 文章结束。是吗？强大的 HTML5 可不这么认为，了解了 <a href="#%E9%9F%B3%E9%A2%91%E5%9B%BE">音频图</a>，你就会知道原来代码不仅可以作画，还可以 <a href="https://www.zhangxinxu.com/wordpress/2017/06/html5-web-audio-api-js-ux-voice/" target="_blank" rel="noopener" title="张鑫旭的博客">写音乐</a>。</p><p>在了解播放音频之前，不妨先来看看这些音乐数据的格式。</p><h2 id="获取数据"><a class="markdownIt-Anchor" href="#获取数据"></a> 获取数据</h2><p>JS 获取二进制数据的方式不少，比较常见的就是读取为 ArrayBuffer 和 Blob。</p><h3 id="file-对象"><a class="markdownIt-Anchor" href="#file-对象"></a> File 对象</h3><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"loadFile(e)"</span>&gt;</span></code></pre><p>使用 <code>&lt;input&gt;</code> 标签上传文件，然后使用 FileReader 对象读取文件。</p><pre class="highlight"><code class="js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loadFile</span>(<span class="hljs-params">e</span>) </span>{<span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> FileReader();reader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{<span class="hljs-keyword">let</span> arrayBuffer = reader.result;<span class="hljs-comment">// 处理 arrayBuffer</span>};reader.readAsArrayBuffer(e.target.files[<span class="hljs-number">0</span>]);}</code></pre><p>此时 <code>arrayBuffer</code> 是 ArrayBuffer 实例，可以通过 <code>Blob()</code> 构造 Blob 对象，进而创建 Blob URL。</p><h3 id="blob-url"><a class="markdownIt-Anchor" href="#blob-url"></a> Blob URL</h3><blockquote><p><code>URL.createObjectURL()</code> 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的 URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的 URL 对象表示指定的 File 对象或 Blob 对象。</p></blockquote><pre class="highlight"><code class="js">reader.load = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> Blob([arrBuf], {<span class="hljs-attr">type</span>: <span class="hljs-string">"audio/wav"</span>});<span class="hljs-keyword">let</span> blobURL = <span class="hljs-built_in">window</span>.URL.createObjectURL(blob);doucment.getElementById(<span class="hljs-string">"audio"</span>).src = blobURL;<span class="hljs-built_in">window</span>.URL.revokeObjectURL(blobURL);<span class="hljs-comment">// 使用完需要释放资源</span>}</code></pre><p>Blob URL 可以像一般的 HTTP URL 引用，但只能在浏览器的单个实例中和同一个会话中。而正是绑定了 document 对象，所以每次使用完尽量释放，尽管页面在关闭时浏览器会自动清理 document。</p><p>实际上 File 继承了 Blob，拥有其所有接口，所以 <code>file</code> 实例其实无需经过 Blob 可直接创建 Blob URL：</p><pre class="highlight"><code class="js">reader.load = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{blobUrl = URL.createObjectURL(e.target.files[<span class="hljs-number">0</span>]);}</code></pre><h3 id="arraybuffer"><a class="markdownIt-Anchor" href="#arraybuffer"></a> ArrayBuffer</h3><p>调用 FileReader 对象的 <code>readAsArrayBuffer()</code> 方法后，读取 <code>result</code> 实例属性，可以获得转换后的 ArrayBuffer 对象，借助 <code>TypedeArray</code> 或 <code>DataView</code> 对象可实现自定义操作。</p><h3 id="xhr"><a class="markdownIt-Anchor" href="#xhr"></a> XHR</h3><p>使用 HTTP 协议的 AJAX，可以发送或者接受二进制文件。</p><ul><li>接受：<pre class="highlight"><code class="js"><span class="hljs-keyword">var</span> XHR = <span class="hljs-keyword">new</span> XMLHttpRequest();XHR.open(<span class="hljs-string">"GET"</span>, <span class="hljs-string">"/myfile.png"</span>, <span class="hljs-literal">true</span>);XHR.responseType = <span class="hljs-string">"arraybuffer"</span>;XHR.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{<span class="hljs-keyword">let</span> buf = XHR.response;<span class="hljs-comment">// 获得 ArrayBuffer</span>}</code></pre><ul><li>也可直接构造 Blob<pre class="highlight"><code class="js"><span class="hljs-keyword">let</span> blob = <span class="hljs-keyword">new</span> Blob([XHR.response], { <span class="hljs-attr">type</span>: <span class="hljs-string">"image/png"</span> });</code></pre></li><li>或者设置 <code>responseType</code> 为 <code>blob</code><pre class="highlight"><code class="js">XHR.responseType = <span class="hljs-string">"blob"</span>;</code></pre></li></ul></li><li>发送：<pre class="highlight"><code class="js"><span class="hljs-keyword">let</span> myArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">512</span>);<span class="hljs-keyword">let</span> longInt8View = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(myArray);<span class="hljs-keyword">let</span> XHR = <span class="hljs-keyword">new</span> XMLHttpRequest();XHR.open(<span class="hljs-string">"POST"</span>, url, <span class="hljs-literal">true</span>);XHR.send(longInt8View);</code></pre>XHR 增强的 <code>send()</code> 方法可直接发送二进制文件。</li></ul><h3 id="websocket"><a class="markdownIt-Anchor" href="#websocket"></a> WebSocket</h3><p>同样 WebSocket 的 <code>send()</code> 方法也可直接发送二进制格式，具体有以下类型：</p><ul><li>USVString</li><li>Blob</li><li>ArrayBuffer</li></ul><p>而接收时，浏览器可能会进行解析，因此必要时需在连接前指定 <code>binarytype</code> 属性。如果发送是以 Blob，那么接收也应该按相同的格式接收。除却 USVString，两种类型大致相同，Blob 适合直接保存为文件，ArrayBuffer 适合在内存中编辑（毕竟有 <code>TypedeArray</code> 和 <code>DataView</code>）。</p><h2 id="音频图"><a class="markdownIt-Anchor" href="#音频图"></a> 音频图？</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API" target="_blank" rel="noopener" title="Web Audio API - MDN">MDN</a> 对 Web Audio API 是这样介绍的：</p><blockquote><p>Web Audio API 使用户可以在<em>音频上下文</em>(AudioContext)中进行音频操作，具有<em>模块化路由</em>的特点。在<em>音频节点</em>上操作进行基础的音频， 它们连接在一起构成<em>音频路由图</em>。</p></blockquote><p>下方还有这样的章节：</p><p><img src="https://s1.ax1x.com/2020/04/28/J42VZF.png" alt="#b# 音频图?" /></p><p>什么是音频图呢？乍接触到时云里雾里的，直接翻文档不知所云，所以还是得先读一读其他的文章。爬帖一波，再结合文档，我整理了如下一张图：</p><p><img src="https://s1.ax1x.com/2020/04/28/J42krT.png" alt="#b# Audio API 的大体结构" /></p><p>可以看到，AudioContext 和 AudioNode 衍生出了一系列对象。不得不说，Web 的对象和 API 真是多，而且相互交织，不画个示意图真不好理解。</p><h3 id="创建-audiocontext"><a class="markdownIt-Anchor" href="#创建-audiocontext"></a> 创建 AudioContext</h3><p>AudioContext 翻译为 <em>音频上下文</em>，对音频的一切操作都在这个环境里进行，就像一个工厂。自然而然的会想到，AudioContext 可以类比 Canvas 中 <code>getContext()</code>。</p><pre class="highlight"><code class="js"><span class="hljs-keyword">const</span> AudioContext = <span class="hljs-built_in">window</span>.AudioContext || <span class="hljs-built_in">window</span>.webkitAudioContext;<span class="hljs-keyword">const</span> audioContext = <span class="hljs-keyword">new</span> AudioContext();</code></pre><p>有了 AudioContext 后，就可以创建音频/视频源了，来源有下面几个。</p><h3 id="audiobuffersourcenode"><a class="markdownIt-Anchor" href="#audiobuffersourcenode"></a> AudioBufferSourceNode</h3><p>AudioBufferSourceNode 对象由 AudioContext 实例的 <code>createBufferSource()</code> 方法创建。</p><p>顾名思义，就是音视频的起点，是一个 AudioNode。有以下常用属性：</p><ul><li><code>buffer</code>：是一个 AudioBuffer 对象，表示要播放的音频</li><li><code>loop</code>：布尔值。是否重播，默认 <code>false</code></li><li><code>connect</code>：继承自 <a href="#audionode" title="跳转到该节">AudioNode</a></li></ul><p>使用以下方法开始和暂停：</p><ul><li><code>start(when[, offset][, duration])</code>：从 <code>when</code> 开始播放<br />只能被播放一次，也就是每次 <code>start()</code> 后，如果想再播放一遍，就需要重新创建，不过创建该节点代价不大</li><li><code>stop([when])</code>：到 <code>when</code> 停止播放<br />不同于 <code>start()</code>，可以多次调用</li></ul><p>该节点的 <code>buffer</code> 属性指向一个 AudioBuffer 对象，这个对象是由 AudioContext 的方法创建的。前面提到，通过 XHR 或者 File 获得二进制文件。我们都知道音视频都有压缩（所以产生了各种压缩格式），播放前得先解码，所以下面两个函数就是用来将之解码为可播放的 buffer。</p><h4 id="decodeaudiodata"><a class="markdownIt-Anchor" href="#decodeaudiodata"></a> <code>decodeAudioData()</code></h4><p>该函数可实现从 <strong>音频文件</strong> 的 ArrayBuffer 异步解码。新版 API 使用 Promise 的形式。</p><pre class="highlight"><code class="js">XHR.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{context.decodeAudioData(XHR.response).then(<span class="hljs-function">(<span class="hljs-params">buffer</span>) =&gt;</span> {<span class="hljs-comment">// 处理 buffer</span>}).catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {<span class="hljs-comment">// 处理错误</span>});};</code></pre><h4 id="createbuffer"><a class="markdownIt-Anchor" href="#createbuffer"></a> <code>createBuffer()</code></h4><p>新建一个空白的 AudioBuffer 对象，以便用于填充数据，通过 AudioBufferSourceNode 播放。</p><pre class="highlight"><code class="js"><span class="hljs-keyword">let</span> ctx = <span class="hljs-keyword">new</span> AudioContext();<span class="hljs-keyword">let</span> emptyBuffer = ctx.createBuffer(numOfChan, len, rate);</code></pre><ul><li><code>numOfChan</code>：声道数</li><li><code>len</code>：长度</li><li><code>rate</code>：采样频率</li></ul><h3 id="audiodestinationnode"><a class="markdownIt-Anchor" href="#audiodestinationnode"></a> AudioDestinationNode</h3><p>为了遵循行文逻辑，而保持层次结构上清晰，这部分见 <a href="#destination"><code>destination</code></a>。</p><h3 id="mediaelementaudiosourcenode"><a class="markdownIt-Anchor" href="#mediaelementaudiosourcenode"></a> MediaElementAudioSourceNode</h3><ul><li>表示由 HTML5 <code>&lt;audio&gt;</code> 或 <code>&lt;video&gt;</code> 元素生成的音频源</li><li>这是一个作为音频源的 AudioNode</li></ul><pre class="highlight"><code class="js"><span class="hljs-keyword">let</span> audioCtx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">window</span>.AudioContext();<span class="hljs-keyword">let</span> audio = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'audio'</span>);<span class="hljs-keyword">let</span> source = audioCtx.createMediaElementSource(audio);</code></pre><h3 id="mediastreamaudiosourcenode"><a class="markdownIt-Anchor" href="#mediastreamaudiosourcenode"></a> MediaStreamAudioSourceNode</h3><ul><li>表示由 WebRTC MediaStream（如网络摄像头或麦克风）生成的音频源</li><li>这是一个作为音频源的 AudioNode</li></ul><pre class="highlight"><code class="js">navigator.mediaDevices.getUserMedia(constraints).then(<span class="hljs-function">(<span class="hljs-params">stream</span>) =&gt;</span> {<span class="hljs-keyword">let</span> audioCtx = <span class="hljs-keyword">new</span> <span class="hljs-built_in">window</span>.AudioContext();<span class="hljs-keyword">let</span> source = audioCtx.createMediaStreamSource(stream);});</code></pre><h2 id="连接-connect"><a class="markdownIt-Anchor" href="#连接-connect"></a> 连接 <code>connect()</code></h2><p>有了起点和音源/视频源，现在可以播放了。怎么操作呢？很简单，连接到扬声器/屏幕就行了。把大象塞到冰箱里的第三步——关上冰箱门。在这里是连接到终点。</p><h3 id="destination"><a class="markdownIt-Anchor" href="#destination"></a> <code>destination</code></h3><p>所谓终点，由 AudioContext 的 <code>destination</code> 定义，是一个 AudioDestinationNode 对象，该对象也是个 AudioNode，一般表示最终的渲染设备。</p><pre class="highlight"><code class="js"><span class="hljs-keyword">let</span> audioCtx = <span class="hljs-keyword">new</span> AudioContext();<span class="hljs-keyword">let</span> source = audioCtx.createMediaElementSource(<span class="hljs-string">"element"</span>);source.connect(audioCtx.destination);</code></pre><p>使用 <code>disconnect()</code> 方法断开连接，可以实现停止播放，再次 <code>connect()</code> 即可继续。</p><p>对于 WebRTC MediaStream，媒体流可以存储在本地文件或者被发送到另外一台计算机，使用 <code>createMediaStreamDestination()</code> 方法创建一个对象，关联一个音频流。</p><pre class="highlight"><code class="js"><span class="hljs-keyword">let</span> audioCtx = <span class="hljs-keyword">new</span> AudioContext();<span class="hljs-keyword">let</span> destination = audioCtx.createMediaStreamDestination();</code></pre><p>现在 <code>&lt;audio&gt;</code> 和 <code>&lt;video&gt;</code> 标签的功能好像都实现了，但 Web Audio API 的功能远不止这些。翻看 MDN 文档，会发现有一堆 <code>*Node</code>，这些对象都是继承自 AudioNode，正如示意图所呈现的。</p><h3 id="audionode"><a class="markdownIt-Anchor" href="#audionode"></a> AudioNode</h3><p>该接口是处理音视频的通用模块，可以衍生出各种不同功能的模块，正如上文多次提到的“作为 <code>AudioNode</code>”</p><ul><li>AudioBufferSourceNode，它的数据来源于一个解码好的完整的 buffer</li><li>GainNode：用于设置音量</li><li>OscillatorNode：用于产生周期性波形</li><li>BiquadFilterNode：用于滤波</li><li>ScriptProcessorNode：用 JS 处理音频，见 <a href="#scriptprocessornode">下文</a></li><li>MediaStreamAudioSourceNode：用于连接麦克风设备</li></ul><p>这些模块既有输入也有输出，可以用装饰者模式一层层 connect，不同的节点可以 <strong>连接</strong> 在一起构建一个处理图。</p><p><img src="https://mdn.mozillademos.org/files/7949/voice-change-o-matic-graph.png" alt="#b# 音频节点图 - MDN" /></p><h3 id="gainnode"><a class="markdownIt-Anchor" href="#gainnode"></a> GainNode</h3><p>是用于修改音量的节点，现在可以写一个音乐播放器了（逃</p><pre class="highlight"><code class="js"><span class="hljs-keyword">let</span> gainNode = context.createGain();source.connect(gainNode);gainNode.connect(context.destination);</code></pre><p>连接好后可以通过修改 <code>value</code> 值更改音量：</p><pre class="highlight"><code class="js">gainNode.gain.value = <span class="hljs-number">0.5</span>;</code></pre><h3 id="代码与艺术"><a class="markdownIt-Anchor" href="#代码与艺术"></a> 代码与艺术</h3><p>借助各式各样的音频模块，处理一段音频或者生成一段音频不在话下，甚至还能用声音作画（AnalyserNode），我不通乐理、不懂声学，暂且不深入学习。分享几个与 Web Audio API 相关的网页：</p><ul><li><a href="http://mdn.github.io/violent-theremin/" target="_blank" rel="noopener">Violent Theremin</a></li><li><a href="https://mdn.github.io/voice-change-o-matic/" target="_blank" rel="noopener">Voice change o matic</a></li><li><a href="https://airtightinteractive.com/demos/js/reactive" target="_blank" rel="noopener">Loop Waveform Visualizer</a></li></ul><p>若有兴趣可移步 <a href="https://github.com/yrq110/odds-and-ends/blob/master/%E6%8A%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%98%E6%88%90%E9%92%A2%E7%90%B4%EF%BC%81Web%20Audio%20API%E5%85%A5%E9%97%A8.md" target="_blank" rel="noopener" title="博客文章">把浏览器变成钢琴！Web Audio API入门</a>。</p><h2 id="录音"><a class="markdownIt-Anchor" href="#录音"></a> 录音</h2><p>大致了解了 Audio API，但还没解决录音的问题，录音这部分资料不是太多，但模式大致相同。</p><ol><li>使用 WebRTC 的 <code>getUserMedia()</code> 获取 MediaStream</li><li>使用这个流初始化（<code>createMediaStreamSource()</code>）一个 <a href="#mediastreamaudiosourcenode">MediaStreamAudioSourceNode</a> 音频模块</li><li>将节点连接到 ScriptProcessorNode（<code>createScriptProcessor()</code>）——使用 JS 处理音频的节点</li><li>设置 ScriptProcessorNode 的 <code>onaudioprocess</code> 事件的回调函数</li></ol><h3 id="scriptprocessornode"><a class="markdownIt-Anchor" href="#scriptprocessornode"></a> ScriptProcessorNode</h3><p>通过这个节点，可以使用 JS 操作音频，进一步让用代码写音乐成为可能。</p><pre class="highlight"><code class="js"><span class="hljs-keyword">let</span> audioCtx = <span class="hljs-keyword">new</span> AudioContext();scriptNode = audioCtx.createScriptProcessor(bufferSize, numrOfIn, numOfOut);</code></pre><ul><li><code>bufferSize</code>：缓冲区大小，应为 2 的幂，通常为 <code>4096</code></li><li><code>numOfIn</code>：输入声道数，默认 <code>2</code>，最高 <code>32</code></li><li><code>numOfOut</code>：输出声道数，默认 <code>2</code>，最高 <code>32</code></li></ul><h3 id="onaudioprocess-事件"><a class="markdownIt-Anchor" href="#onaudioprocess-事件"></a> <code>onaudioprocess</code> 事件</h3><p>该事件对象有以下两个缓冲区（AudioBuffer 对象）：</p><ul><li><code>inputBuffer</code></li><li><code>outputBuffer</code></li></ul><p>使用 <code>getChannelData(num)</code> 方法可获得该 <code>num</code> 声道的数据，数据以 Float32Array 对象存储。</p><pre class="highlight"><code class="js"><span class="hljs-keyword">const</span> onAudioProcess = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {    <span class="hljs-keyword">let</span> audioBuffer = event.inputBuffer;    <span class="hljs-keyword">let</span> leftChannelData = audioBuffer.getChannelData(<span class="hljs-number">0</span>),rightChannelData = audioBuffer.getChannelData(<span class="hljs-number">1</span>);<span class="hljs-comment">// 处理两个声道的数据</span>}</code></pre><h3 id="合并声道"><a class="markdownIt-Anchor" href="#合并声道"></a> 合并声道</h3><p>各个声道是分离的，如果要存储然后播放，按时间先后排布显然是不行的，所以要合并，左右声道交叉存储和播放。</p><pre class="highlight"><code class="js"><span class="hljs-comment">// 交叉合并左右声道的数据</span><span class="hljs-keyword">const</span> combine = <span class="hljs-function">(<span class="hljs-params">left, right</span>) =&gt;</span> {    <span class="hljs-keyword">let</span> totalLength = left.length + right.length;    <span class="hljs-keyword">let</span> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>(totalLength);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; left.length; i += <span class="hljs-number">2</span>) {        data[k] = left[i];        data[k + <span class="hljs-number">1</span>] = right[i];    }    <span class="hljs-keyword">return</span> data;}</code></pre><h3 id="编码并传输"><a class="markdownIt-Anchor" href="#编码并传输"></a> 编码并传输</h3><p>编码为 WAV 格式的函数经过不断改进，可以直接使用。编码以及压缩后的数据（Blob）可以直接保存/发送。但是在实时通信的场景下，数据应该是源源不断地产生和消耗，所以要用到流。开辟一块缓冲区，隔一段时间取出发送，并清空缓冲区，当这个间隔时间大小合适，就能产生实时的效果。</p><p>感谢腾讯 AlloyTeam 全端团队来自 2015 年的 <a href="http://www.alloyteam.com/2015/12/websockets-ability-to-explore-it-with-voice-pictures" target="_blank" rel="noopener">文章</a>，给出了 Audio API 结合 WebSocket 进行录制与传输的方案。我在此基础上稍作修改，分理出两个类，项目的烂代码还没开源，为不影响阅读暂把前人的智慧贴在文章末尾。（可自定义的参数太多了，全部提取出来有点繁琐，所以部分参数硬编码了。）</p><h2 id="推荐阅读"><a class="markdownIt-Anchor" href="#推荐阅读"></a> 推荐阅读</h2><blockquote><p>注意本节内容列出阅读的文章，虽然也是写作本文的参考文章，读到这里时也建议移步吸取灵感。</p></blockquote><ol><li><a href="https://juejin.im/post/599e35f5f265da246c4a1910" target="_blank" rel="noopener">深入浅出 Web Audio Api - 掘金</a></li><li><a href="https://juejin.im/entry/588ca34e8fd9c5d09bbcaad4" target="_blank" rel="noopener">大话Web-Audio-Api - 掘金</a></li><li><a href="https://juejin.im/post/5cbfdd4ee51d456e6f45c721" target="_blank" rel="noopener">初识HTML5 Web Audio API - 掘金</a></li><li><a href="https://juejin.im/post/5b8bf7e3e51d4538c210c6b0" target="_blank" rel="noopener">如何实现前端录音功能 - 掘金</a></li><li><a href="https://segmentfault.com/a/1190000010561222" target="_blank" rel="noopener">HTML5音频API Web Audio - 思否</a></li><li><a href="https://www.jianshu.com/p/62790429acef" target="_blank" rel="noopener">基于WebSocket的在线聊天室（一） - 简书</a></li><li><a href="https://www.jianshu.com/p/03a74d489f34" target="_blank" rel="noopener">基于WebSocket的在线聊天室（二） - 简书</a></li><li><a href="http://www.alloyteam.com/2015/12/websockets-ability-to-explore-it-with-voice-pictures" target="_blank" rel="noopener">websocket 探索其与语音、图片的能力</a></li><li><a href="https://github.com/yrq110/odds-and-ends/blob/master/%E6%8A%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%98%E6%88%90%E9%92%A2%E7%90%B4%EF%BC%81Web%20Audio%20API%E5%85%A5%E9%97%A8.md" target="_blank" rel="noopener">把浏览器变成钢琴！Web Audio API入门</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API" target="_blank" rel="noopener">Web Audio API - MDN</a></li></ol><h2 id="附录代码"><a class="markdownIt-Anchor" href="#附录代码"></a> 附录：代码</h2><pre class="highlight"><code class="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SAudioData</span> </span>{<span class="hljs-keyword">constructor</span>(rate) {<span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>; <span class="hljs-comment">// 录音文件长度</span><span class="hljs-keyword">this</span>.buffer = []; <span class="hljs-comment">// 录音缓存</span><span class="hljs-keyword">this</span>.inputSampleRate = rate; <span class="hljs-comment">// 输入采样率</span><span class="hljs-keyword">this</span>.outputSampleRate = <span class="hljs-number">44100</span> / <span class="hljs-number">6</span>; <span class="hljs-comment">// 输出的采样率,取决于平台</span><span class="hljs-keyword">this</span>.inputSampleBits = <span class="hljs-number">16</span>; <span class="hljs-comment">// 输入采样位数 8, 16</span><span class="hljs-keyword">this</span>.outputSampleBits = <span class="hljs-number">8</span>; <span class="hljs-comment">// 输出采样位数 8, 16</span>}<span class="hljs-comment">// 填入缓冲区</span>inputData = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {<span class="hljs-keyword">this</span>.buffer.push(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>(data));<span class="hljs-keyword">this</span>.size += data.length;};<span class="hljs-comment">// 清理缓冲区</span>clearData = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<span class="hljs-keyword">this</span>.buffer = [];};<span class="hljs-comment">// 合并压缩</span>compress = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-keyword">var</span> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>(<span class="hljs-keyword">this</span>.size);<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.buffer.length; i++) {data.set(<span class="hljs-keyword">this</span>.buffer[i], offset);offset += <span class="hljs-keyword">this</span>.buffer[i].length;}<span class="hljs-comment">// 压缩</span><span class="hljs-keyword">var</span> compression = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">this</span>.inputSampleRate / <span class="hljs-keyword">this</span>.outputSampleRate);<span class="hljs-keyword">var</span> length = data.length / compression;<span class="hljs-keyword">var</span> result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Float32Array</span>(length);<span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (index &lt; length) {result[index] = data[j];j += compression;index++;}<span class="hljs-keyword">return</span> result;};<span class="hljs-comment">// 编码为 WAV，Blob</span>encodeWAV = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-keyword">var</span> sampleRate = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.inputSampleRate, <span class="hljs-keyword">this</span>.outputSampleRate);<span class="hljs-keyword">var</span> sampleBits = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.inputSampleBits, <span class="hljs-keyword">this</span>.outputSampleBits);<span class="hljs-keyword">var</span> bytes = <span class="hljs-keyword">this</span>.compress();<span class="hljs-keyword">var</span> dataLength = bytes.length * (sampleBits / <span class="hljs-number">8</span>);<span class="hljs-keyword">var</span> buffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ArrayBuffer</span>(<span class="hljs-number">44</span> + dataLength);<span class="hljs-keyword">var</span> data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DataView</span>(buffer);<span class="hljs-keyword">var</span> channelCount = <span class="hljs-number">1</span>; <span class="hljs-comment">// 单声道</span><span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>;<span class="hljs-keyword">var</span> writeString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>{<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i++) {data.setUint8(offset + i, str.charCodeAt(i));}};writeString(<span class="hljs-string">"RIFF"</span>); <span class="hljs-comment">// 资源交换文件标识符</span>offset += <span class="hljs-number">4</span>;data.setUint32(offset, <span class="hljs-number">36</span> + dataLength, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 下个地址开始到文件尾总字节数，即文件大小 -8</span>offset += <span class="hljs-number">4</span>;writeString(<span class="hljs-string">"WAVE"</span>); <span class="hljs-comment">// WAV 文件标志</span>offset += <span class="hljs-number">4</span>;writeString(<span class="hljs-string">"fmt "</span>); <span class="hljs-comment">// 波形格式标志</span>offset += <span class="hljs-number">4</span>;data.setUint32(offset, <span class="hljs-number">16</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 过滤字节,一般为 0x10 = 16</span>offset += <span class="hljs-number">4</span>;data.setUint16(offset, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 格式类别 (PCM 形式采样数据)</span>offset += <span class="hljs-number">2</span>;data.setUint16(offset, channelCount, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 通道数</span>offset += <span class="hljs-number">2</span>;data.setUint32(offset, sampleRate, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 采样率，每秒样本数,表示每个通道的播放速度</span>offset += <span class="hljs-number">4</span>;data.setUint32(offset, channelCount * sampleRate * (sampleBits / <span class="hljs-number">8</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// 波形数据传输率 (每秒平均字节数) 单声道×每秒数据位数×每样本数据位/8</span>offset += <span class="hljs-number">4</span>;data.setUint16(offset, channelCount * (sampleBits / <span class="hljs-number">8</span>), <span class="hljs-literal">true</span>); <span class="hljs-comment">// 快数据调整数 采样一次占用字节数 单声道×每样本的数据位数/8</span>offset += <span class="hljs-number">2</span>;data.setUint16(offset, sampleBits, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 每样本数据位数</span>offset += <span class="hljs-number">2</span>;writeString(<span class="hljs-string">"data"</span>); <span class="hljs-comment">// 数据标识符</span>offset += <span class="hljs-number">4</span>;data.setUint32(offset, dataLength, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 采样数据总数，即数据总大小-44</span>offset += <span class="hljs-number">4</span>;<span class="hljs-comment">// 写入数据</span><span class="hljs-keyword">if</span> (sampleBits === <span class="hljs-number">8</span>) {<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; bytes.length; i++, offset++) {<span class="hljs-keyword">var</span> s = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">-1</span>, <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">1</span>, bytes[i]));<span class="hljs-keyword">var</span> val = s &lt; <span class="hljs-number">0</span> ? s * <span class="hljs-number">0x8000</span> : s * <span class="hljs-number">0x7fff</span>;val = <span class="hljs-built_in">parseInt</span>(<span class="hljs-number">255</span> / (<span class="hljs-number">65535</span> / (val + <span class="hljs-number">32768</span>)));data.setInt8(offset, val, <span class="hljs-literal">true</span>);}} <span class="hljs-keyword">else</span> {<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; bytes.length; i++, offset += <span class="hljs-number">2</span>) {<span class="hljs-keyword">var</span> s = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">-1</span>, <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">1</span>, bytes[i]));data.setInt16(offset, s &lt; <span class="hljs-number">0</span> ? s * <span class="hljs-number">0x8000</span> : s * <span class="hljs-number">0x7fff</span>, <span class="hljs-literal">true</span>);}}<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Blob([data], { <span class="hljs-attr">type</span>: <span class="hljs-string">"audio/wav"</span> });};}</code></pre><pre class="highlight"><code class="js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SRecorder</span> </span>{<span class="hljs-keyword">constructor</span>(stream) {<span class="hljs-keyword">this</span>.clock = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 循环定时器</span><span class="hljs-comment">// 音频处理接口</span><span class="hljs-keyword">this</span>.audioContext = <span class="hljs-keyword">new</span> AudioContext();<span class="hljs-comment">// 通过音频流创建输入音频对象</span><span class="hljs-keyword">this</span>.audioInput = <span class="hljs-keyword">this</span>.audioContext.createMediaStreamSource(stream);<span class="hljs-comment">// 创建音频数据对象</span><span class="hljs-keyword">this</span>.audioData = <span class="hljs-keyword">new</span> SAudioData(<span class="hljs-keyword">this</span>.audioContext.sampleRate);<span class="hljs-comment">// 创建音量对象</span><span class="hljs-keyword">this</span>.audioVolume = <span class="hljs-keyword">this</span>.audioContext.createGain();<span class="hljs-comment">// 创建录音机对象</span><span class="hljs-keyword">this</span>.recorder = <span class="hljs-keyword">this</span>.audioContext.createScriptProcessor(<span class="hljs-number">4096</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">this</span>.recorder.onaudioprocess = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {<span class="hljs-keyword">this</span>.audioData.inputData(e.inputBuffer.getChannelData(<span class="hljs-number">0</span>));};}<span class="hljs-comment">// 开始录音</span>start = <span class="hljs-function">(<span class="hljs-params">callback = <span class="hljs-literal">null</span></span>) =&gt;</span> {<span class="hljs-keyword">this</span>.audioInput.connect(<span class="hljs-keyword">this</span>.audioVolume);<span class="hljs-keyword">this</span>.audioVolume.connect(<span class="hljs-keyword">this</span>.recorder);<span class="hljs-keyword">this</span>.recorder.connect(<span class="hljs-keyword">this</span>.audioContext.destination);callback &amp;&amp; <span class="hljs-keyword">this</span>.cycle(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> callback(data));};<span class="hljs-comment">// 停止录音</span>stop = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-keyword">this</span>.recorder.disconnect();clearTimeout(<span class="hljs-keyword">this</span>.clock);};<span class="hljs-comment">// 暂停录音</span>pause = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-keyword">this</span>.audioVolume.disconnect();clearTimeout(<span class="hljs-keyword">this</span>.clock);};<span class="hljs-comment">// 继续录音</span><span class="hljs-keyword">continue</span> = <span class="hljs-function">(<span class="hljs-params">callback = <span class="hljs-literal">null</span></span>) =&gt;</span> {<span class="hljs-keyword">this</span>.recorder.connect(<span class="hljs-keyword">this</span>.audioContext.destination);callback &amp;&amp; <span class="hljs-keyword">this</span>.cycle(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> callback(data));};<span class="hljs-comment">// 获取 WAV 数据</span>getWav = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.audioData.encodeWAV();};<span class="hljs-comment">// 清除缓冲区</span>clear = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<span class="hljs-keyword">this</span>.audioData.clearData();};<span class="hljs-comment">// 循环拉取缓冲数据，使用 `callback()` 发送出去，该方法适用于流</span>cycle = <span class="hljs-function">(<span class="hljs-params">callback, time = <span class="hljs-number">500</span></span>) =&gt;</span> {<span class="hljs-keyword">let</span> bTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();callback(<span class="hljs-keyword">this</span>.getWav());<span class="hljs-keyword">this</span>.clear();<span class="hljs-keyword">this</span>.clock = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.cycle(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> callback(data), time),time - (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() - bTime));};}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取 GitBook 站点的文档</title>
      <link href="/2020/03/%E8%8E%B7%E5%8F%96-GitBook-%E7%AB%99%E7%82%B9%E7%9A%84%E6%96%87%E6%A1%A3/"/>
      <url>/2020/03/%E8%8E%B7%E5%8F%96-GitBook-%E7%AB%99%E7%82%B9%E7%9A%84%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="tldr"><a class="markdownIt-Anchor" href="#tldr"></a> TL;DR</h2><p>wget 加 <code>-m</code> 选项下载站点资源，然后使用 Python 提供的 SimpleHTTPServer 搭建简易服务器，可以实现在本地访问文档。</p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>有些网站如果不用一些手段的话，访问速度特别慢，尤其是提供在线内容的网站比如官方文档，点半天没反应 <s>对，就是 GitHub 和 GitBook</s>，开发体验极差。如果能本地访问就好了，像 Java 开发可能会查阅 CHM 格式的 API 手册，速度就会快很多，还有一些文档工具，综合了大量离线文档，如 <a href="https://kapeli.com/dash" target="_blank" rel="noopener" title="主页">Dash</a> 及与之对应的 <a href="https://zealdocs.org/" target="_blank" rel="noopener" title="主页">Zeal</a>。</p><p>此处提供一个站点，可离线存储文档：<a href="https://devdocs.io/" target="_blank" rel="noopener" title="主页">https://devdocs.io/</a>，用的前端技术栈。</p><p>水这么一篇文章，是因为最近阅读 <a href="https://chenxiaowei.gitbook.io/cpp_concurrency_in_action/" target="_blank" rel="noopener" title="文档">《C++ 并发编程》</a>，切换页面速度太慢了，得想办法搞下来 &lt;.&lt;</p><h2 id="下载静态资源"><a class="markdownIt-Anchor" href="#下载静态资源"></a> 下载静态资源</h2><p>大多数文档都使用 <a href="https://www.gitbook.com/" target="_blank" rel="noopener" title="主页">GitBook</a> 制作并托管，而 GitBook 是个静态页面，因此对于这类网页，可以下载静态资源到本地，从而加快访问速度。</p><p>正好该网站是用 GitBook 托管，每个页面都是 HTML 文件，所以在本地找个目录，<a href="https://www.gnu.org/software/wget/" target="_blank" rel="noopener" title="主页">wget</a> 一把梭。</p><pre class="highlight"><code class="bash">$ wget -m https://xxx.xxx.com</code></pre><p>其中，<code>-m</code> 是 <code>-N -r -l inf --no-remove-listing</code> 的缩写形式。</p><p>还可以使用如下选项：</p><pre class="highlight"><code class="bash">$ wget -k -r -c https://xxx.xxx.com</code></pre><ul><li><code>-k, --convert-links</code>：让下载得到的 HTML 或 CSS 中的链接指向本地文件</li><li><code>-r, --recursive</code>：指定递归下载</li><li><code>-c, --continue</code>：断点续传下载文件</li><li><code>-np, --no-parent</code>：不追溯至父级，即只下载某子目录</li></ul><p>类似工具还有 <a href="http://www.httrack.com" target="_blank" rel="noopener" title="主页">HTTrack</a> 等，可以镜像一个网站。</p><p>一波操作之后，在该目录就得到了网站的资源，双击 <code>index.html</code>（如果有的话），一个克隆网站映入眼帘，点击一个链接，如果没有使用 <code>-k</code> 选项的话，链接可能会失效，因为 URL 路径问题，关于 <code>file</code> 协议，<a href="https://palmcivet.github.io/2020/02/Github-%E4%B8%8E-SPA-%E9%83%A8%E7%BD%B2/" title="文章">这里</a> 有提到。</p><p><img src="https://s1.ax1x.com/2020/03/13/8KheFx.png" alt="#b# 网站资源 download 到本地" /></p><h2 id="托管页面"><a class="markdownIt-Anchor" href="#托管页面"></a> 托管页面</h2><p>众所周知，使用 Apache 或者 Nginx 托管静态页面再好不过，但是为了查一下文档在生产机安装服务端软件属实欠妥，最为上乘的是轻量级的解决方案如使用一个脚本启动一个服务器。随手一查，果然存在。</p><p>SimpleHTTPServer 是 Python 2 自带的一个模块，是 Python 的 Web 服务器。它在 Python 3 已经合并到 <code>http.server</code> 模块中。SimpleHTTPServer 在 Python 3 的用法与在 Python 2 的用法相似。</p><p>在终端进入一个目录，执行命令：</p><pre class="highlight"><code class="bash">$ python -m SimpleHTTPServer 6789$ python3 -m http.server 6789</code></pre><p>使用浏览器输入 <a href="http://127.0.0.1:6789" target="_blank" rel="noopener" title="打开">127.0.0.1:6789</a> 或 <a href="http://0.0.0.0:6789" target="_blank" rel="noopener" title="打开">0.0.0.0:6789</a> 即可访问。</p><p><img src="https://s1.ax1x.com/2020/03/13/8KhEwR.png" alt="访问之，可看到日志记录" /></p><p>若当前目录存在 <code>index.html</code>，则默认显示该页面，否则显示为文件目录。</p><p><img src="https://s1.ax1x.com/2020/03/13/8KhVT1.png" alt="运行在本地的文档页面" /></p><p>其实 GitBook 也可以提供脚本和文件，可以在本地用这种方式运行一个网站的。&gt;.&lt;</p><h2 id="随时启动"><a class="markdownIt-Anchor" href="#随时启动"></a> 随时启动</h2><p>每次输命令哪够啊，肯定得 <code>alias</code> 一下，此后轻轻松松就可以打开服务器浏览任意文件了，开发的时候也可以做测试。<s>当然香还是 Webpack 的 DevServer 香</s>。</p><p>编辑 Shell 的配置文件（我使用 Zsh：<code>~/.zshrc</code>）：</p><pre class="highlight"><code class="bash"><span class="hljs-built_in">alias</span> simple=<span class="hljs-string">"python3 -m http.server 9999"</span></code></pre><p>对于 macOS，有一个 <code>open</code> 命令，可以指定浏览器打开某个页面，如 <code>open https://www.bing.com</code> 使用默认浏览器打开 <a href="https://www.bing.com" target="_blank" rel="noopener" title="主页">Bing</a>。当然也可指定浏览器，使用 <code>-a</code> 选项，比如 <code>open -a Firefox https://www.bing.com</code>。</p><p><code>-a</code> 选项其实是用来打开软件的，就是 <code>/Applications</code> 文件夹下的应用程序，URL 只是个参数。</p><p>回过头来，命令设置如下：</p><pre class="highlight"><code class="bash"><span class="hljs-built_in">alias</span> simple=<span class="hljs-string">"open http://0.0.0.0:9999 &amp;&amp; python3 -m http.server 9999"</span></code></pre><p>因 SimpleHTTPServer 打开后一直处于前台运行，况且打开软件需要响应时间，所以将 <code>open</code> 命令提到前面，这样的调用顺序正好并行处理。打开后窗口的焦点落于浏览器，获得极致体验。</p><p>可以使用 <code>&amp;</code> 将命令放到后台而不占用终端，但简易服务器应随开随关，后台运行似乎不妥。</p><h2 id="局域网访问"><a class="markdownIt-Anchor" href="#局域网访问"></a> 局域网访问</h2><p>在局域网（使用无线路由器连接的家庭网络）内，PC、笔记本和手机等设备在同一网段，可通过内网相互访问。</p><p><img src="https://s1.ax1x.com/2020/03/13/8MpW8S.png" alt="查看 IP" /></p><p>查看一下 IP，绑定了本机地址，所以其他设备连接本机 IP 即可访问该页面：</p><p><img src="https://s1.ax1x.com/2020/03/13/8MC1T1.jpg" alt="#b# 移动端访问本地文档" /></p><h2 id="题外话apache"><a class="markdownIt-Anchor" href="#题外话apache"></a> 题外话：Apache</h2><p>macOS 系统对开发的友好之处就在于内置了一些必要的软件，曾经翻系统目录的时候找到过如下内容：</p><p><img src="https://s1.ax1x.com/2020/03/13/8KhAm9.png" alt="#b# macOS 内置的 WebServer" /></p><p>没错正是 <a href="http://httpd.apache.org/" target="_blank" rel="noopener" title="主页">Apache httpd</a>，虽然见怪不怪，但在 macOS 上找到 Apache 多少还是有点惊讶的</p><p><img src="https://s1.ax1x.com/2020/03/13/8KhmY6.png" alt="#b# macOS 内置的 Apache" /></p><p>对于这个 httpd，可使用如下命令查看版本：</p><pre class="highlight"><code class="bash">$ apachectl -version</code></pre><h3 id="启动与停用"><a class="markdownIt-Anchor" href="#启动与停用"></a> 启动与停用</h3><p>httpd 的管理需要 <code>sudo</code> 权限，默认运行在 <a href="http://0.0.0.0:80" target="_blank" rel="noopener" title="打开"><code>80</code></a> 端口。</p><pre class="highlight"><code class="bash">$ sudo apachectl start$ sudo apachectl stop$ sudo apachectl restart</code></pre><p>打开浏览器查看，可以看到，后端操作系统是 UNIX（即 Darwin）。</p><p><img src="https://s1.ax1x.com/2020/03/13/8KhnfK.png" alt="It works！" /></p><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p>网站根目录为 <code>/Library/WebServer/Documents/</code>。可编辑配置文件：</p><pre class="highlight"><code class="bash">$ sudo vi /etc/apache2/httpd.conf</code></pre><p>具体配置项不做介绍，按照 Apache 文档配置即可。</p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>可以想象，在下载时网站的流量必然不小，因此需审慎下载，此外，对于这类资源，应尊重作者的劳动成果，譬如我下载的文档是作者的译文，不应用作其他用途。</p><p>SimpleHTTPServer，Python2 就有了，十几年前吧，我应该不是最后一个知道 ╮(╯▽╰)╭，不过貌似以前看到过。但至少我知道，Python 可以架设一个 Web 服务器。好，就这样，水了一篇文章。</p>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Wget </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub 与 SPA 部署</title>
      <link href="/2020/02/Github-%E4%B8%8E-SPA-%E9%83%A8%E7%BD%B2/"/>
      <url>/2020/02/Github-%E4%B8%8E-SPA-%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>最近在写一个 <a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="noopener" title="Wiki">单页面应用</a>，用来练习 <a href="https://redux.js.org/" target="_blank" rel="noopener" title="主页">Redux</a>，其中用到了 <a href="https://reacttraining.com/react-router/" target="_blank" rel="noopener" title="主页">React Router</a> 库，<s>实际开发过程中，Redux 用的挺顺手，Router 反而不会用了。</s> 采用前后端分离的方式。本地调试一直都是起一个 devServer，写完了登录页，扔给后端同学测一下，却反馈说双击打开一片空白。</p><p>确实，我之前使用 Router 库，预览的时候也是不能直接打开，因为路径问题，我默认 <code>/</code> 为主页，因此 <code>file:///xxx/index.html</code> 这个 URL 显然不匹配，而 <code>index.html</code> 文件是有效的，只是 JS 处理路由的代码没执行而已，因此使用服务器，默认访问 <code>/</code> 就是 <code>index.html</code>，就忽略了 URL 差异。</p><h2 id="file"><a class="markdownIt-Anchor" href="#file"></a> <code>file:///</code></h2><p>先来看一下 file，在电脑上双击 HTML 文件，可以在浏览器打开，访问其页面，有很多应用如 <a href="https://merricx.github.io/qrazybox/" target="_blank" rel="noopener" title="主页">QRazyBox</a> 就是这样做到离线使用。</p><p>其实这是一个协议，就如同 HTTP 协议：</p><pre class="highlight"><code class="">protocol :// hostname[:port] / path / [;parameters][?query]#fragment</code></pre><p>而需注意，<em>file</em> 是三条 <code>/</code>，Google Chrome 默认不显示协议名称，将地址栏的内容复制出来则会自动加上。为什么是三条 <code>/</code> 呢，这要看 <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier" target="_blank" rel="noopener" title="Wiki">URI</a> 的定义：</p><pre class="highlight"><code class="">scheme : [//[user:password@] host [:port]] [/] path [?query] [#fragment]</code></pre><p>以 <code>https://www.zhihu.com/question/37063799</code> 为例，<code>www.zhihu.com</code> 是 <em>host</em>（主机名）， 后面的属于 <code>path</code>，而如果是本地文件，<em>host</em> 部分就不需要了，所以合起来就变成了 <code>///</code>，但根据 <code>[]</code>，其实两个 <code>//</code> 都应该省略的。</p><p>再看 <em>file</em> 协议，它是用于访问本地计算机中的文件，就如同在 Windows 资源管理器中打开文件一样，注意它是针对本地（本机）的，简单说，file 协议是访问本机的文件资源。</p><pre class="highlight"><code class="">file:///C:/Users/Admin/file.avi</code></pre><p>就相当于</p><pre class="highlight"><code class="">C:/Users/Admin/file.avi</code></pre><p>访问本地 HTML，其实是在本地起了一台 HTTP 服务器，然后访问电脑上的本地服务器，HTTP 服务器再去访问本机的文件资源。<br />曾经虚拟机玩的不熟，增强工具总是安装失败，就考虑通过网络来共享文件，在 Ubuntu 里成功部署过 SMB 服务器，然后通过 Windows 下的资源管理器访问，在地址栏输入 <code>\\192.168.1.1</code> 访问，就可以像在本机一样操作 <s>远程</s> 主机，如同局域网共享（实际上本来就是，Windows 支持很多共享协议）。</p><p>在浏览器的地址栏输入 <code>file:///</code> 就可以看到本机的文件（目录）了，有点类似 FTP 站点。</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQHTf.png" alt="#b# 访问本地文件" /></p><p>再回到 <em>file</em> 协议打开 HTML 的问题，访问 <code>index.html</code>，会引入该文件需要的静态文件，而如果脚本文件又引入（<code>import</code>）了其他文件，在这里则是无效的，我们可以做个实验：</p><pre class="highlight"><code class="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> test = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b;</code></pre><p>写上述脚本命名为 <code>test.js</code></p><pre class="highlight"><code class="js"><span class="hljs-keyword">import</span> { test } <span class="hljs-keyword">from</span> <span class="hljs-string">"./test"</span>;<span class="hljs-built_in">console</span>.log(test(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));</code></pre><p>再在以上代码内引用，保存并命名为 <code>main.js</code>，通过 <code>&lt;script&gt;</code> 插入到一份 HTML 文件，访问就可以得到一个 Error：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQ4ld.png" alt="#b# 加载失败" /></p><p><s>Chrome 显然已经支持了很多 ES6 语法。</s> 加载 <code>test.js</code> 需要服务器解析并返回，所以开发者工具的 Source 以及 Network 会有一堆文件（当然，ES6 以及 JS 模块的原理还是很深奥，这里不深入了），<em>file</em> 协议这里仅是静态的访问，就跟资源管理器（或 Finder）里打开一样，无法参与解析。当然，不引用外部文件，或者直接在 HTML 文件里，JS 脚本是可以执行的。</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQ56A.png" alt="#b# 直接执行" /></p><p>那么既然了解了直接打开文件的原理，又该如何处理前言这个问题呢？理论上，直接浏览器打开文件是可行的，毕竟 React 只有一个 HTML 和一个 JS（当然也可以有多个），我没用 Router 库之前也是直接打开的，<s>对，用了之后就不行了。</s> 在我没有意识到我可以修改路由之前，我进行了一些 <s>搜索</s> 尝试。</p><h2 id="spa"><a class="markdownIt-Anchor" href="#spa"></a> SPA</h2><p>众所周知，SPA 这个概念是比较新的，在大前端时代，新概念、新技术层出不穷，SPA、MPA、PWA、SSR、Hybrid、Native，<s>这几个名词并不具有一定的关系</s> 可以引出宽广的技术栈。</p><p>SPA 就是单页面应用，只有一个 HTML 页面，原理类似点击一个按钮通过 JS 的 DOM 操作创建一个节点然后显示出来，但可以更改地址栏的 URL，然后 JS 通过 URL（History）的变化渲染对应组件，不同于动态网站，浏览器 URL 怎么变都跟服务器无关（实际上这就是静态网页）。</p><p>是吗？似乎不全是，React Router 切换路径不会发送请求，还是当前的 HTML（以及 JS）处理这个 URL（即 <em>前端路由</em>），但是一刷新，或者不是访问 <code>/</code>（或者 <code>index.html</code>），而是访问 <code>/home</code>（假如网页有该路径），实际上这两者是一个效果，都是向服务器请求 <code>/home</code>，但前面提到，URL 变化跟服务器无关，服务器哪认得这个 URL，<s>我静态网页只托管 <code>index.html</code>，其他的没有</s>，一个 404 打发回去，这与通常的动态网页不同，后端是不匹配（实际上是没有）路由的。</p><h2 id="spa-部署"><a class="markdownIt-Anchor" href="#spa-部署"></a> SPA 部署</h2><p>所以，问题很明显了，SPA 需要专门的部署方式。后端采用 Tomcat，带入关键词一搜，果然圈内普遍存在这种部署问题。前端路由的问题，React Router 和 Vue Router 都会遇到，解决方案很简单，使用 Node.js 服务器即可（逃</p><p>这并不能解决问题，我调试用的就是基于 Express 的 devServer，刷新或者热更新就找不到了（<s><code>historyApiFallback</code> 无效，因为有一个基地址</s>），需要手动更改 URL。搜索结果更多的是使用 <strong>重定向</strong> 来解决，将后端未知的 URL 请求重定向回去（即还是交给 <code>index.html</code> 处理），就可以了。</p><h3 id="nginx"><a class="markdownIt-Anchor" href="#nginx"></a> Nginx</h3><p>Nginx 作为高性能服务器，静态资源托管的大哥，转发流量是不在话下，<code>server</code> 块只需要加一句处理 fallback。</p><pre class="highlight"><code class="nginx"><span class="hljs-section">server</span> {    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span>  www.example.com;    <span class="hljs-attribute">root</span> /mnt/html/spa;    <span class="hljs-attribute">index</span> index.html;    <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/favicon\.ico$</span> {        <span class="hljs-attribute">root</span> /mnt/html/spa;    }    <span class="hljs-attribute">location</span> / {        <span class="hljs-attribute">try_files</span> <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ <span class="hljs-variable">@fallback</span>;        <span class="hljs-attribute">index</span> index.html;        <span class="hljs-attribute">proxy_set_header</span>   Host             <span class="hljs-variable">$host</span>;        <span class="hljs-attribute">proxy_set_header</span>   X-Real-IP        <span class="hljs-variable">$remote_addr</span>;        <span class="hljs-attribute">proxy_set_header</span>   X-Forwarded-For  <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;        <span class="hljs-attribute">proxy_set_header</span>   X-Forwarded-Proto  <span class="hljs-variable">$scheme</span>;    }    <span class="hljs-attribute">location</span> <span class="hljs-variable">@fallback</span> {        <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^.*$</span> /index.html <span class="hljs-literal">break</span>;    }    <span class="hljs-attribute">access_log</span>  /mnt/logs/nginx/access.log  main;}</code></pre><h3 id="tomcat"><a class="markdownIt-Anchor" href="#tomcat"></a> Tomcat</h3><p>后端主 Java 技术栈，使用 Tomcat 部署。对于汤姆猫，需要在 <code>web.xml</code> 文件设置 404 页面。</p><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">error-page</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">error-code</span>&gt;</span>404<span class="hljs-tag">&lt;/<span class="hljs-name">error-code</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">location</span>&gt;</span>/spa/index.html<span class="hljs-tag">&lt;/<span class="hljs-name">location</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">error-page</span>&gt;</span></code></pre><h3 id="apache"><a class="markdownIt-Anchor" href="#apache"></a> Apache</h3><p>Apache httpd 是修改 <code>httpd.conf</code>。</p><ol><li>打开 <code>mod_rewrite.so</code> 模块，取消注释<pre class="highlight"><code class="ini">LoadModule rewrite_module modules/mod_rewrite.so</code></pre></li><li>修改 <code>AllowOverride</code> 选项，将 <code>None</code> 改为 <code>All</code><pre class="highlight"><code class="ini">AllowOverride All</code></pre></li><li>建立 <code>.htacess</code> 文件放入网站文件夹（也可以在 <code>httpd-vhosts.conf</code> 文件中设置）<pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">IfModule</span> <span class="hljs-attr">mod_rewrite.c</span>&gt;</span>RewriteEngine OnRewriteBase /RewriteRule ^index\.html$ - [L]RewriteCond %{REQUEST_FILENAME} !-fRewriteCond %{REQUEST_FILENAME} !-dRewriteRule . /index.html [L]<span class="hljs-tag">&lt;/<span class="hljs-name">IfModule</span>&gt;</span></code></pre></li></ol><h2 id="github-pages"><a class="markdownIt-Anchor" href="#github-pages"></a> GitHub Pages</h2><h3 id="静态网页"><a class="markdownIt-Anchor" href="#静态网页"></a> 静态网页</h3><p>倒腾了很久，后来意识到我可以修改路由，不必让首页匹配 <code>/</code>，就是说，<s>是我编码问题，跟 SPA 关系不大。</s> 使其跟普通页面一样，一进入就有内容，这样首先能解决点击空白的问题，再搭配服务器重定向的策略，就能解决刷新返回 404 的问题，如此，即可实现正常访问了。</p><p>很好，但是我每一个逻辑页面都有在判断路由，这样一改，首页就没法判断了，这时候，就用到了 <s>（学到了）</s> React Router 一个组件，<a href="https://reacttraining.com/react-router/web/api/withRouter" target="_blank" rel="noopener" title="文档"><code>&lt;withRouter /&gt;</code></a> 高阶组件，把 <code>location</code>、<code>history</code>、<code>match</code> 等路由组件才有的信息注入普通组件，这样，首页就也能判断路由了。完美解决问题。</p><p>于是，我的 SPA 跟普通静态网页彻底一致了，既然是静态页面，就可以托管在 <strong>GitHub Pages</strong> 上，如此一来，可以实现真正的前后端分离，不必配置汤姆猫了。<s>（但会带来跨域问题。）</s></p><h3 id="静态网站生成器"><a class="markdownIt-Anchor" href="#静态网站生成器"></a> 静态网站生成器</h3><p>我们都知道，Github 提供了 <a href="https://help.github.com/en/github/working-with-github-pages" target="_blank" rel="noopener" title="文档">GitHub Pages</a> 服务，用于项目展示，Geek 们利用这个特性可以制作个人主页、搭建博客，于是涌现了很多网站生成器，如 <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener" title="主页">Hexo</a>、<a href="https://gohugo.io" target="_blank" rel="noopener" title="主页">Hugo</a>，还有官方推荐的基于 Ruby 的 Jekyll 等等。</p><p>这些工具都有一个特点，生成的网页都是静态的，因为 GitHub Pages 只能托管静态网页。对于动态网页，言必及 WordPress，使用 WordPress 是需要自己准备服务器的。而不同于服务端组织页面来返回，静态页面是直接托管在服务器上已存在的内容，访问就能得到。静态网站生成器的作用，就是帮助用户 <strong>生成好所有页面</strong>，这样上传到服务器（Github）就能直接访问。</p><p>使用 GitHub Pages 搭建个人博客，我们都知道是建立一个 <strong>以用户名命名</strong> 的仓库，形如 <code>&lt;user&gt;.github.io</code>，开启了 GitHub Pages，然后即可通过 <code>http(s)://&lt;user&gt;.github.io/</code> 访问。</p><p><img src="https://help.github.com/assets/images/help/pages/create-repository-name-pages.png" alt="#b# 图片来自官方文档" /></p><p>每个项目都可以启用 GitHub Pages。经常可以看到一些网站的 URL 类似 <code>http(s)://&lt;user&gt;.github.io/&lt;repo&gt;</code>，比如 Element for React：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQ70P.png" alt="#b# Element-React" /></p><p>通常一个仓库 Setting 页的 GitHub Pages 设置如下：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DlC7V.png" alt="#b# 普通仓库的 GitHub Pages" /></p><p>能够看到，可以选用当前 Repo 的 <code>master</code> 分支托管网站，也可以使用 <code>master</code> 分支的 <code>docs</code> 文件夹。实际上不一定需要托管在主分支。当 Repo 设立了 <code>gh-pages</code> 分支，Github Pages 的 Option 会多出来该分支：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQjpQ.png" alt="#b# 设立了 gh-pages" /></p><p>再看 Element-React 项目的 Github：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQqk8.png" alt="#b# Element-React 的 gh-pages 分支" /></p><p>根据 <a href="https://help.github.com/en/github/working-with-github-pages/about-github-pages" target="_blank" rel="noopener" title="官方文档">官方文档</a>，个人站点和组织站点是类似的，默认使用 <code>master</code> 分支，项目站点默认使用 <code>gh-pages</code>，也可以使用 <code>master</code> 分支或 <code>master</code> 分支上的 <code>/docs</code> 文件夹。</p><h3 id="404-not-found"><a class="markdownIt-Anchor" href="#404-not-found"></a> 404 Not Found</h3><p>这样就好了吗？正如标题所云，还没解决 SPA 刷新造成 404 的问题，如果是被请求的服务器可以将请求重定向回 <code>index.html</code>，但静态网站访问之后，资源找不到就是找不到。所以 GitHub 提供了 <a href="https://help.github.com/en/github/working-with-github-pages/creating-a-custom-404-page-for-your-github-pages-site" target="_blank" rel="noopener" title="官方文档">自定义 404 页面</a> 的功能，找不到资源时，会搜索 <code>404.html</code> 或 <code>404.md</code>，Geek 们可以自定义样式和内容。</p><p>同样，针对 SPA 的路由，知乎有这样一个 <a href="https://www.zhihu.com/question/64173754" target="_blank" rel="noopener" title="知乎">问题及回答</a>：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQzXn.png" alt="#b# 知乎问答" /></p><p>题主及答主给出了几种修复 URL 的方案：</p><ol><li>通过 sessionStorage 存储之前的地址，然后跳转到新地址里并读取之前存储的内容，重新 route</li><li>把当前地址作为参数跳转到 <code>index.html</code></li><li>复制 <code>index.html</code> 到 <code>404.html</code> 最简单粗暴，不过没准效果是最好的</li><li>让 <code>404.html</code> 直接获取 <code>index.html</code>，然后直接把它丢到文档流里</li></ol><p>最初我使用了 Hack 的方法，在 <code>404.html</code> 读取 <code>windwos.location</code>，修改 URL，将路径变为哈希字符串，然后使用  <code>history.replaceState()</code> 跳转到 <code>index.html</code>，主页检测 URL 再还原回来，但是效果不理想。<s>应该是我编码（不对，思路）问题。</s> 最后直接复制 <code>index.html</code> 为 <code>404.html</code>，试下来，真应了这句话：</p><blockquote><p>最简单粗暴，不过没准效果是最好的……</p></blockquote><p>故而，假使不好处理 404 的问题，不妨也复制一份 index 文件，立竿见影。</p><h2 id="github-actions"><a class="markdownIt-Anchor" href="#github-actions"></a> GitHub Actions</h2><p>使用 GitHub Pages 托管静态网站最简单的方法，就是在 <code>master</code> 分支上创一个 <code>/docs</code> 文件夹，然后 <code>build</code> 出文件，随源代码提交，即可热更新，非常酷炫。</p><p>这还不够酷，<a href="https://github.com/features/actions" target="_blank" rel="noopener" title="主页">GitHub Actions</a> 了解一下。GitHub Actions 是 GitHub 的 <a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener" title="阮一峰的博文">持续集成</a> 服务，于 2018 年 10 月推出。官方是这样描述的：</p><blockquote><p>GitHub Actions makes it easy to automate all your software workflows, now with world-class CI/CD. Build, test, and deploy your code right from GitHub. Make code reviews, branch management, and issue triaging work the way you want.</p></blockquote><p>对于一个项目来说，写完代码还没完事，还要经过测试、部署等等一系列工作，这是正常流程，但每次提交、修复 bug 或者添加新特性，都要走一遍这样的流程，自然会觉得烦。“重复 3 次以上的工作都要用程序来自动化”，因此有了 <a href="https://travis-ci.org" target="_blank" rel="noopener" title="主页">Travis</a>、<a href="https://pre-commit.com/hooks" target="_blank" rel="noopener" title="主页">Pre-commit Hooks</a> 等工具，帮助开发者实现部分自动化，很多 Repo 里都有类似 <code>.travis.yml</code> 的文件。自从 GitHub 推出了 Actions 功能，这一历史就将改写，因为从代码提交到部署上线这一过程更加原生，一条龙服务 <s>，如果不用 Github，那就当我没说</s>。（对，Github 不只是托管代码，当然，GitLab、Gitee 也都在积极提出 CI/CD 和 DevOps 产品，以适应现代开发理念，更好的迎合市场需求。）</p><p>简而言之，Github Actions 就是提供一个环境，在某些条件下，可以执行一些操作。这个条件（配置文件的 <code>on</code> 字段）可以是 <code>push</code>、<code>issue</code>、PR 或是其他；执行的操作可以是编译、测试、fork、commit、发布等等，只要有配置文件，就能自动执行；所运行的环境可以是 Linux、Windows 以及 macOS（对，macOS 也支持，不过限制更多一点），硬件如下：</p><ul><li>2-core CPU</li><li>7 GB of RAM memory</li><li>14 GB of SSD disk space</li></ul><p>也可以自建环境（self-hosted），比如自己的树莓派（self-hosted runner）。借助 GitHub Actions，作为个人开发者我们可以实现每次提交源码，自动测试编译打包，然后发布到自己的平台（VPS 或者 GitHub Pages），当然 Geek 的想象力是无限的，Actions 能做的远远不止于此。</p><p>该功能入口在此：</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQIOI.png" alt="#b# GitHub Actions" /></p><p>据 <a href="https://help.github.com/cn/actions/automating-your-workflow-with-github-actions" target="_blank" rel="noopener">文档</a> 所述，Action 有以下几个概念：</p><ol><li><em>workflow</em>：持续集成运行一次的过程，就是一个 workflow</li><li><em>job</em>：一个 workflow 由一个或多个 jobs 构成，含义是一次持续集成的运行，可以完成多个任务。多个 job 是并发执行的</li><li><em>step</em>：每个 job 由多个 step 构成，一步步完成，因此可以指定顺序（即依赖关系：<code>needs</code> 字段）</li><li><em>action</em>：每个 step 可以依次执行一个或多个命令（action）</li></ol><p>workflow 想必各位有点耳熟，iOS 上的 App <a href="https://apps.apple.com/cn/app/id915249334" target="_blank" rel="noopener">捷径</a> 被收购前就叫 <em>Workflow</em>，产品如其名，可以自动化处理一些操作，Actions 也一样。</p><h3 id="actions-加持"><a class="markdownIt-Anchor" href="#actions-加持"></a> Actions 加持</h3><p>所以我盘算使用 GitHub Actions 来自动部署我的 SPA。Actions 的配置文件存放在 Repo 根目录的 <code>./github/workflow</code> 文件夹下，使用 YAML 语法配置。关于配置项，官方文档给的很详细，还提供了了编辑器，各位大牛的教程也很到位，这里不再赘述。以下是我这个项目的 workflow：</p><pre class="highlight"><code class="yml"><span class="hljs-attr">name:</span> <span class="hljs-string">SPA</span> <span class="hljs-string">Deployer</span><span class="hljs-attr">on:</span>  <span class="hljs-attr">push:</span>    <span class="hljs-attr">branches:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><span class="hljs-attr">jobs:</span>  <span class="hljs-attr">build-deploy:</span>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-18.04</span>    <span class="hljs-attr">steps:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v1</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node</span>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v1</span>        <span class="hljs-attr">with:</span>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">'10.x'</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">install</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">run:</span> <span class="hljs-string">yarn</span> <span class="hljs-string">release</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span>        <span class="hljs-attr">uses:</span> <span class="hljs-string">peaceiris/actions-gh-pages@v2</span>        <span class="hljs-attr">env:</span>          <span class="hljs-attr">ACTIONS_DEPLOY_KEY:</span> <span class="hljs-string">$</span>          <span class="hljs-attr">PUBLISH_BRANCH:</span> <span class="hljs-string">gh-pages</span>          <span class="hljs-attr">PUBLISH_DIR:</span> <span class="hljs-string">./public/release</span></code></pre><p>使用自己指定的 <code>yarn release</code> 命令，将文件编译到 <code>./public/release</code> 文件夹。用到了如下 Actions：</p><ol><li><a href="https://github.com/marketplace/actions/checkout" target="_blank" rel="noopener" title="Marketplace">actions/checkout</a><ul><li><a href="https://github.com/actions/checkout" target="_blank" rel="noopener" title="GitHub">GitHub</a></li><li>切换分支，即拉取代码</li></ul></li><li><a href="https://github.com/marketplace/actions/setup-node-js-for-use-with-actions" target="_blank" rel="noopener" title="Marketplace">actions/setup-node</a><ul><li><a href="https://github.com/actions/setup-node" target="_blank" rel="noopener" title="GitHub">GitHub</a></li><li>安装 Node.js，此后即可使用 Node 命令</li><li>同样支持 Yarn，之前我以为不支持，还找了另外的 actions：<a href="https://github.com/marketplace/actions/github-action-for-yarn" target="_blank" rel="noopener" title="Marketplace">GitHub Actions for Yarn</a></li></ul></li><li><a href="https://github.com/marketplace/actions/github-pages-action" target="_blank" rel="noopener" title="Marketplace">actions-gh-pages</a><ul><li><a href="https://github.com/peaceiris/actions-gh-pages" target="_blank" rel="noopener" title="GitHub">GitHub</a></li><li>主角。部署项目到 <code>gh-pages</code> 分支（其他分支也可）</li><li>注意 <code>env</code> 的 <code>ACTIONS_DEPLOY_KEY</code> 是 SSH 私钥</li><li>具体操作见 <a href="https://github.com/peaceiris/actions-gh-pages/blob/master/README.md" target="_blank" rel="noopener" title="GitHub README">README</a></li></ul></li></ol><p>至此，SPA 项目可以实现在 GitHub 上提交后自动构建并发布，与后端彻底分离。</p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>试错阶段失败了很多次，最后终于成功了。</p><p><img src="https://s2.ax1x.com/2020/02/04/1DQTmt.png" alt="#b# 构建失败" /></p><p>通过这一系列部署，学到了很多操作。运维不同于开发，求稳而不求变，遵循一定的流程，难怪需要大量自动化脚本，继而又涌现了大量 Docker、K8S 等自动化部署工具和 <a href="https://jenkins.io/" target="_blank" rel="noopener" title="主页">Jenkins</a> 等持续集成工具。<strong>技术改变世界</strong>，相信使用脚本刀耕火种的日子不复存在。</p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://juejin.im/post/5dc4ae67f265da4cfa7bbb9a" target="_blank" rel="noopener">前端部署发展史</a></li><li><a href="https://jsonz1993.github.io/2019/12/github-actions/" target="_blank" rel="noopener">用github actions部署你的应用(hexo)</a></li><li><a href="https://help.github.com/cn/actions/automating-your-workflow-with-github-actions" target="_blank" rel="noopener">Github Action 文档</a></li><li><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">GitHub Actions 入门教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 C 语言指针二三事</title>
      <link href="/2020/01/%E5%85%B3%E4%BA%8E-C-%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
      <url>/2020/01/%E5%85%B3%E4%BA%8E-C-%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>学习 C 语言到现在已经一年了，自从部署好 DPDK 到现在也过去了半年，但是对 DPDK 的学习却半点都没有深入，虽然主观上时间、魄力、方法这三者没有到位，但从客观上讲，掌握 C 语言尤其是指针实属不易，不过这也足够吸引人。</p><p>大概半年前，学习了 UNIX 环境下的 C 编程，才窥见这门古老语言的魅力。此后与人谈及就说 C 语言由宏和结构体组成，通过指针相互操作。有一次了解到 <a href="http://nginx.org/" target="_blank" rel="noopener" title="Nginx 主页">Nginx</a> 里四级指针满天飞，惊诧于战斗民族的剽悍之风。再者，封面的代码，又该如何解释？</p><pre class="highlight"><code class="c">(*(<span class="hljs-keyword">void</span> (*)())<span class="hljs-number">0</span>)()</code></pre><p>既知指针是过不去的坎，最近发现几本 C 指针和 C 现代编程方法的书，就此又将学习 C 语言提上日程，本篇文章权当读书笔记以及感悟。</p><h3 id="标准"><a class="markdownIt-Anchor" href="#标准"></a> 标准</h3><p>C 语言标准有很多，<a href="https://www.sourcetrail.com" target="_blank" rel="noopener" title="Sourcetrail 主页">Sourcetrail</a> 居然给出了这么多版本：</p><p><img src="https://s2.ax1x.com/2020/01/19/1CjG59.png" alt="#b# C 标准的版本" /></p><p>总的来说，C 语言经历了如下发展：</p><ol><li><p><em>K&amp;R C</em>：1972 年，<em>Dennis Ritchie</em> 改进了 <a href="https://en.wikipedia.org/wiki/B_(programming_language)" target="_blank" rel="noopener" title="Wiki">B 语言</a>，被称为 <em>NB</em>（New B），又称 <em>K&amp;R C</em></p></li><li><p><em>ANSI C</em></p><ol><li>1989 年，ANSI 推出 ANSI C 的 89 版标准</li><li>1990 年，ISO 推出 ISO C90</li></ol><p>实际上，<em>ISO C90</em> 和 <em>ANSI C89</em> 是同一个规范，因为 ISO 采纳了 ANSI C。由于 ANSI 早于 ISO 推出，因此通常称这个版本为 <em>ANSI C89</em></p></li><li><p><em>C99</em>：2000 年 3 月，ANSI 采纳了 <em>ISO/IEC 9899:1999</em> 标准，称为 <em>C99</em></p></li><li><p><em>C11</em>：2011 年由 <em>ISO/IEC</em> 发布，C 语言标准的第三版，也被称为 <em>C1X</em>，指 ISO 标准 <em>ISO/IEC 9899:2011</em></p></li></ol><h3 id="环境"><a class="markdownIt-Anchor" href="#环境"></a> 环境</h3><p>本文基于 C99（C11 引入了很多特性，值得玩味），使用最通用的写法，测试环境如下：</p><ul><li>编译器：LLVM version 10.0.1 (<code>clang-1001.0.46.4</code>)</li><li>平台：<code>x86_64-apple-darwin18.7.0</code></li></ul><h2 id="初探指针"><a class="markdownIt-Anchor" href="#初探指针"></a> 初探指针</h2><p>先来看一个简单的例子：</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-keyword">int</span> foo = <span class="hljs-number">5</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"foo:    %p\n"</span>, foo);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;foo:   %p\n"</span>, &amp;foo);    <span class="hljs-keyword">int</span> * p;    p = &amp;foo;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"p:      %p\n"</span>, p);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"*p:     %p\n"</span>, *p);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;p:     %p\n"</span>, &amp;p);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p>编译运行，如果不出意外的话，应该得到以下输出:</p><pre class="highlight"><code class="">foo:    0x5&amp;foo:   0x7ffee8ba3988p:      0x7ffee8ba3988*p:     0x5&amp;p:     0x7ffee8ba3980</code></pre><p>实际上编译得到两个 <code>warning</code>：应将打印 <code>*p</code> 的格式字符 <code>%d</code> 替换为 <code>%d</code>，<s>但是 who care?</s> 此处为了统一，将 <code>*p</code> 也以地址格式输出。</p><p>例程做了几件事：</p><ol><li>先定义一个变量 <code>foo</code>，初始化之后，很容易知道，值和地址分别为 <code>5</code> 和 <code>0x...988</code></li><li>再定义一个指针 <code>p</code>，将 <code>foo</code> 的地址赋给它，此时：<ul><li><code>p</code> 是 <code>foo</code> 的地址</li><li><code>*p</code> 是 <code>foo</code> 的值</li><li><code>&amp;p</code> 是 <code>p</code> 的地址</li></ul></li></ol><blockquote><p>为方便起见，在后续的例子中，省略了 <code>main()</code> 函数等代码，只在必要处给予说明。另由于现代操作系统地址随机化等内存保护措施，每次执行程序，变量的地址不一定相同，但绝对偏移是固定的，这点需要注意。</p></blockquote><h3 id="声明指针变量"><a class="markdownIt-Anchor" href="#声明指针变量"></a> 声明指针变量</h3><p>声明时，使用 <code>*</code> 代表要声明的变量是指针：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> *p;</code></pre><p>但我们有时候也看到：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span>* p;<span class="hljs-keyword">double</span> * p;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>;</code></pre><p>以上都是声明指针变量，<code>int</code> 是关键字，<code>int*</code> 显然不是（不会影响到对 <code>int</code> 的声明，但其实是声明 <code>int</code> 型的指针，后文会提到），在这种情况下，空格可有可无，实际上在 C 语言编译过程中，会忽略空格符、制表符和换行符。</p><p>所以只要逻辑没问题，下面代码可以如愿执行：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span>    bar     =     <span class="hljs-number">6</span>;    <span class="hljs-built_in">printf</span>(    <span class="hljs-string">"66%d!\n"</span>   <span class="hljs-comment">// 字符是一个整体，所以不能换行</span>      ,    bar);</code></pre><p>但是这种代码风格太抽象了，如果不想去世的话，不建议这么写。相信连自己也会看不下去的。</p><p>好，既然 <code>*</code> 放在哪都没有区别，那为什么会有 <code>int* p</code> 和 <code>int *p</code> 两种截然不同的形式存在呢？<s>当我 <code>int * p</code> 不存在。</s></p><p>通常，C 语言的声明格式类似 <code>类型 变量名</code>，如 <code>float pai</code> 声明类型为 <code>folat</code> 的变量 <code>pai</code>，而像 <code>double *pointer</code> 则是声明类型为 <code>double</code> 的指针变量 <strong><code>pointer</code></strong>，注意并不是 <code>*pointer</code>，因此，写成 <code>double*</code> 将之作为类型名似乎更合理，但请注意：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span>* foo, bar, p = <span class="hljs-number">9</span>;</code></pre><p>其中只有 <code>foo</code> 是指针变量。可见，C 语言极其<s>混乱</s>灵活，很多现象<strong>不能一概而论</strong>。</p><h3 id="使用指针"><a class="markdownIt-Anchor" href="#使用指针"></a> 使用指针</h3><p>实际上第一个例程已经使用过了指针，这里再来总结一下。</p><ul><li>标识符（即指针变量）的 <strong>值是地址</strong></li><li><code>*</code> 解引用，根据地址得到所代表的的值（字符或数值）</li><li><code>&amp;</code> 获得变量的地址，可以用来将其他对象的 <strong>地址值</strong> 赋给指针变量</li></ul><p>指针变量存储的值是地址，所以以下代码，编译器不认为是定义指针，将产生 <code>incompatible integer to pointer conversion initializing 'double *' with an expression of type 'double'</code> 的 <code>warning</code>。</p><pre class="highlight"><code class="c"><span class="hljs-keyword">double</span> * p = <span class="hljs-number">3.14</span>;</code></pre><p>但把值换成字符串就又可以了,甚至还可以通过指针来访问，所以说 C 语言很多现象不能一概而论。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">char</span> * p = <span class="hljs-string">"hahaha"</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, p);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{        <span class="hljs-keyword">char</span> * q = <span class="hljs-string">"that's ok"</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, q);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\n"</span>, *(q+<span class="hljs-number">2</span>));        func();        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p>实际上字符串会作为只读变量单独存放，将以上代码反汇编后可以看到两处的字符串都作为常量存储在某一区域。</p><p><img src="https://s2.ax1x.com/2020/01/19/1CjNgx.png" alt="#b# 反汇编后的符号表" /></p><h2 id="二探指针"><a class="markdownIt-Anchor" href="#二探指针"></a> 二探指针</h2><h3 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h3><p>可能大多数 C 语言教材都会提到，一个数组 <code>arr[9]</code>，在表达式中如果只给出数组名 <code>arr</code>，其实就代表 <code>arr[0]</code>。</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> arr[] = { <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> };<span class="hljs-keyword">int</span> *p;p = arr;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"arr:        %p\n"</span>, arr);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;arr[0]:    %p\n"</span>, &amp;arr[<span class="hljs-number">0</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"p:          %p\n"</span>, p);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"arr[0]:     %p\n"</span>, arr[<span class="hljs-number">0</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"*p:         %p\n"</span>, *p);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"*arr:       %p\n"</span>, *arr);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"arr[1]:     %p\n"</span>, arr[<span class="hljs-number">1</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"*(p+1)):    %p\n"</span>, *(p + <span class="hljs-number">1</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"*(arr+1):   %p\n"</span>, *(arr + <span class="hljs-number">1</span>));</code></pre><p>以上例程运行结果如下：</p><pre class="highlight"><code class="">arr:        0x7ffee8461970&amp;arr[0]:    0x7ffee8461970p:          0x7ffee8461970arr[0]:     0x0*p:         0x0*arr:       0x0arr[1]:     0x1*(p+1):     0x1*(arr+1):   0x1</code></pre><p>可以得到以下几个结论：</p><ol><li>作为表达式，数组名 <code>arr</code> 和指向该数组的指针变量 <code>p</code> 一样，其值都是地址</li><li>作为表达式，数组名 <code>arr</code> 的地址值与其第一个元素的地址值相同</li><li><code>arr[i]</code> 与 <code>*(arr + i)</code> 等效</li></ol><h3 id="下标运算符"><a class="markdownIt-Anchor" href="#下标运算符"></a> 下标运算符 <code>[]</code></h3><blockquote><p>声明中的 <code>[]</code> 和表达式中的 <code>[]</code> 意义不同，就跟声明中的 <code>*</code> 和表达式中的 <code>*</code> 意义不同一样。</p></blockquote><p>实际上，<code>arr[i]</code> 只是 <code>*(arr+i)</code> 的语法糖（syntax sugar）。</p><p>为什么说 <code>[]</code> 是语法糖呢？</p><p>引用轮子哥的 <a href="https://www.zhihu.com/question/24207261/answer/27023844" target="_blank" rel="noopener">回答</a>：</p><ol><li>如果去掉了一个功能，语言有些事情就做不了了，这就不是语法糖，而是基础功能</li><li>如果去掉了一个功能，语言做那些事情只是麻烦了一点点，这就是语言功能重复，或者只是提供了缩写功能</li><li>如果去掉了一个功能，语言做那些事情还是能做，但是实在是麻烦太多了，这就是语法糖了</li></ol><p>以一个三维数组为例：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> d_3_arr[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = {    {        {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>},        {<span class="hljs-number">3</span>, <span class="hljs-number">4</span>},        {<span class="hljs-number">5</span>, <span class="hljs-number">6</span>},    },    {        {<span class="hljs-number">7</span>, <span class="hljs-number">8</span>},        {<span class="hljs-number">9</span>, <span class="hljs-number">10</span>},    },    {        {<span class="hljs-number">11</span>, <span class="hljs-number">12</span>},        {<span class="hljs-number">13</span>, <span class="hljs-number">14</span>},    }};</code></pre><p>要访问 <code>13</code>，使用 <code>[]</code> 的形式为 <code>d_3_arr[2][1][0]</code>，使用指针的形式则为 <code>*(*(*(d_3_arr + 2) + 1) + 0)</code>。</p><p>似乎跟做梦一样。使用指针运算的形式不仅需要开发者耗费精力去计算下标，还要注意书写，写错一个 <code>()</code> 或者 <code>*</code> 就会出问题。这两种写法孰优孰劣，不难辨知。</p><p>众所周知，C 语言没有多维数组，有也是靠一维数组模拟出来的。使用 <code>for</code> 循环遍历该三维数组，可以得到各元素的地址，示意如下：</p><p><img src="https://s2.ax1x.com/2020/01/19/1CjUv6.png" alt="#b# 多维数组内存分布图" /></p><p>可以清晰地看到，数组元素是线性分布的，数组初始化时指定了元素因此用 <code>0</code> 填补空缺，在我的环境下，<code>int</code> 型的数组每个元素占 <code>4</code> 字节。</p><p>数组的起始地址自然就是数组第一个元素的地址。当我们使用 <code>d_3_arr + 1</code> 得到的值就是红框部分数组的起始地址，以此类推。</p><blockquote><p>大家可以计算一下 <code>*(d_3_arr + 2) + 1</code> 及其对应的值是多少。</p></blockquote><p>现在来看一个骚操作：</p><ol><li>众所周知，<code>*(p+i)</code> 和 <code>*(i+p)</code> 显然是一样的</li><li>而 <code>p[i]</code> 又是 <code>*(p+i)</code> 的语法糖</li><li>所以，<code>p[i]</code> 又可以写成 <code>i[p]</code></li></ol><p>接上面的例子，以下代码可验证成功：</p><pre class="highlight"><code class="c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"arr[1]:     %p\n"</span>, arr[<span class="hljs-number">1</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"1[arr]:     %p\n"</span>, <span class="hljs-number">1</span>[arr]);</code></pre><h3 id="作为函数参数"><a class="markdownIt-Anchor" href="#作为函数参数"></a> 作为函数参数</h3><p>我们知道，函数内不能修改实参的值，但是通过指针可以，函数不能传数组，但是传指针可以。</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>])</span></span>;</code></pre><p>在声明函数形参时，数组或被自动解读成指针，即使指定了元素个数也会被忽略，所以以上写法最终都会被理解成第一种形式。</p><p>还有一个著名的例子便是 <code>main()</code> 函数，声明成如下形式时（而不是 <code>int main(void);</code>），可获得命令行参数。</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * argv[])</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> ** argv)</span></span>;</code></pre><ul><li><code>argc</code>：参数个数</li><li><code>argv</code>：包含参数字符串的二维数组</li></ul><p>再看一个较复杂的例子：</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[][<span class="hljs-number">5</span>])</span></span>;  <span class="hljs-comment">// 1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*a)[<span class="hljs-number">5</span>])</span></span>; <span class="hljs-comment">// 2</span></code></pre><p><code>a</code> 是个 <code>int</code> 型的二维数组，该数组的元素是一个 <code>int</code> 型的拥有 <code>5</code> 个元素的数组，而 <code>a</code> 这个数组的元素个数不需要明确，因为 <code>a</code> 最终会转成指针（如 <code>2</code> 所示）。</p><p>但有一点需要注意，声明的仅仅是指针，没有指定长度，所以在遍历数组时需要注意边界，或者在声明函数时就指定数组大小，就像 <code>main()</code> 函数中的 <code>argc</code> 一样。</p><h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3><p>C 语言中，定义 <strong>字符串</strong> 常量使用 <code>char</code> 数组</p><pre class="highlight"><code class="c"><span class="hljs-keyword">char</span> str[] = <span class="hljs-string">"@_$tr1n9"</span>;</code></pre><p>实际上，上述是一种省略形式，会被编译器特别解释为：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">char</span> str[] = { <span class="hljs-string">'@'</span>, <span class="hljs-string">'_'</span>, <span class="hljs-string">'$'</span>, <span class="hljs-string">'t'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'n'</span>, <span class="hljs-string">'9'</span>, <span class="hljs-string">'\0'</span> };</code></pre><p>此后，我们可以通过数组的方法（下标运算符或指针运算）访问、修改该数组的内容。</p><pre class="highlight"><code class="c">str[<span class="hljs-number">0</span>] = <span class="hljs-string">'a'</span>;*(str+<span class="hljs-number">2</span>) = <span class="hljs-string">'s'</span>;</code></pre><p>此外，字符串也可以使用指针来定义，但无法修改内容，否则会报总线错误，因为使用这种方法定义，指针指向的是只读区域（见 <a href="#%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88">使用指针</a> 一节）的字符串起始位置。</p><pre class="highlight"><code class="c"><span class="hljs-keyword">char</span> *<span class="hljs-built_in">string</span> = <span class="hljs-string">"abc"</span>;<span class="hljs-built_in">string</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">'d'</span>;    <span class="hljs-comment">// bus error</span></code></pre><p>通过以下语句，可验证字符串常量是数组：</p><pre class="highlight"><code class="c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-string">"abcdefg"</span>));    <span class="hljs-comment">// 8</span></code></pre><p>正因为如此，我们可以使用以下方式获得字符：</p><pre class="highlight"><code class="c"><span class="hljs-string">"0123456789"</span>[<span class="hljs-number">2</span>]</code></pre><h2 id="三探指针"><a class="markdownIt-Anchor" href="#三探指针"></a> 三探指针</h2><h3 id="指向函数的指针"><a class="markdownIt-Anchor" href="#指向函数的指针"></a> 指向函数的指针</h3><p>先来看看函数名是个什么东西。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>{    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hh\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"func:   %p\n"</span>, func);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"&amp;func:  %p\n"</span>, &amp;func);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p>运行结果如下：</p><pre class="highlight"><code class="">func:0x10b56cf20&amp;func:0x10b56cf20</code></pre><p>正如数组名在表达式中可以被解读成指针一样，函数名也意味着指向函数的指针，其标识符就是初始地址。实际上各种类型都是如此————标识符是起始地址，只不过数组、结构体等有大小，而函数没有大小。</p><p>如果想在函数里调用另一个函数，这很简单，直接通过标识符调用即可。<strong>接上例</strong>， <code>main()</code> 函数中使用如下语句都可成功调用 <code>func()</code> 函数：</p><pre class="highlight"><code class="c">func();(*func)();</code></pre><p>只要能获得 <code>func</code> 这个标识符或者说对应的地址即可。</p><p>但如果标识符不确定呢？即函数名未知，该如何调用？</p><p>参照函数传参，如果将被调函数的起始地址传入主调函数，即可调用之。函数在表达式中，应理解成指向函数的指针，比如在信号处理程序中：</p><pre class="highlight"><code class="c">signal(SIGSEGV, segv_handle);signal(SIGSEGV, &amp;segv_handle);</code></pre><p>我们已经知道，以上两种方式都是传递函数的起始地址，然后按照之前提到的调用方式，所以都能成功。</p><p>似乎很合理，但是主调函数的声明尤其是参数表该怎么写？这就涉及到函数指针了。</p><p>来看这个例程：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*callee)())</span></span>{    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a: hhh\n"</span>);    callee();}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>{    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"b: hhhh\n"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{    a(b);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p>其中，<code>int (*callee)()</code> 是一个函数指针，其标识符（即形参）为 <code>callee</code>，就跟 <code>int func(int *a)</code> 这样的声明没什么两样，只不过声明函数需要带括号 <code>()</code>。</p><p>同样，类比普通变量的指针，函数指针也可以获得另一个函数的地址，从而代为调用。看以下例程的  <code>*(func)()</code> 函数：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">void</span> (*func)();<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*callee)())</span></span>{        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"a: hhh\n"</span>);        callee();}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span>{        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"b: hhhh\n"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{        func = a;        func(b);    <span class="hljs-comment">// (*func)(b); 与之相同</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;}</code></pre><p>现在，函数指针 <code>func</code> 可以绑定任何与之类型相同的函数，并且调用了。</p><p>上面这句话提到了一个词————<em>类型</em>，现在来看这个迟到的概念。</p><h3 id="派生类型"><a class="markdownIt-Anchor" href="#派生类型"></a> 派生类型</h3><p>C 语言类型有基本类型和派生类型之分。</p><pre class="highlight"><code class="c"><span class="hljs-keyword">double</span> *p;<span class="hljs-keyword">int</span> (*func[<span class="hljs-number">9</span>])(<span class="hljs-keyword">float</span>);</code></pre><p>参照《征服 C 指针》中“类型链的表示”，以上类型可图示如下：</p><p><img src="https://s2.ax1x.com/2020/01/19/1CjYCR.png" alt="#b# 类型链表示" /></p><p>链最后面的（即图中第一个）元素是基本类型，后面的则都是派生类型。</p><p>好，现在可以群魔乱舞了。如何解读以下语句（<a href="https://zhuanlan.zhihu.com/p/85191629" target="_blank" rel="noopener" title="知乎专栏">来自知乎专栏</a>）？</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> **p;<span class="hljs-keyword">int</span> *p[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">10</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;<span class="hljs-keyword">int</span> (*p)(<span class="hljs-keyword">int</span>);<span class="hljs-keyword">int</span> (*p[<span class="hljs-number">10</span>])(<span class="hljs-keyword">int</span>);</code></pre><p>首先要明确，不管类型链画成什么花，类型都是由基本类型和指针、数组、函数、结构体等派生类型组成的，而派生类型可以不断（递归或者重复）组合，就可以生成无限种派生类型。而每种类型都有类别，同样借用《征服 C 指针》中的概念，称这种类别为 <em>类型分类</em>。</p><p>对于“类型链”表示里的两个例子，我们不加解释（解释方法见下文）地给出解读：</p><ol><li><code>p</code> 是一个指向 <code>double</code> 的 <strong>指针</strong></li><li><code>func</code> 是一个拥有 <code>9</code> 个元素（并且元素为指向（参数为 <code>float</code>、返回值为 <code>int</code> 的函数）的指针）的 <strong>数组</strong></li></ol><p>可以看到，这样的解读类似下定义，其宾语就是 <em>类型分类</em>，同时也是链的第一个（即图中最后一个）元素。就像二维数组 <code>arr[m][n]</code> 一样，把数组抽象成子元素，层层嵌套。</p><h3 id="解读-c-声明"><a class="markdownIt-Anchor" href="#解读-c-声明"></a> 解读 C 声明</h3><p>所以，怎么来明确这个 <em>类型分类</em> 呢？或者说如何得到类型链的表示呢？</p><p>借用《征服 C 指针》的方法：</p><blockquote><p>在这里，向读者介绍阅读 C 语言声明的方法：机械地向前读。</p><p>为了把问题变得简单，我们在这里不考虑 <code>const</code> 和 <code>volatile</code>。接下来遵循以下步骤来解释 C 的声明。</p><ol><li>首先着眼于标识符（变量名或者函数名）。</li><li>从距离标识符最近的地方开始，依照优先顺序解释派生类型（指针、数组和函数）。优先顺序如下：<ol><li>用于整理声明内容的括弧</li><li>用于表示数组的 <code>[]</code>，用于表示函数的 <code>()</code></li><li>用于表示指针的 <code>*</code></li></ol></li><li>解释完成派生类型，使用 “of”、“to”、“returning” 将它们连接起来。</li><li>最后追加数据类型修饰符（在左边，<code>int</code>、<code>double</code> 等）。</li><li>英语不好的人，可以倒序用日语（或者中文）解释。</li></ol></blockquote><p>个人认为最主要的就是第 <code>1</code> 步和第 <code>2</code> 步，可以明确 <em>类型分类</em>，至于其它，都是定语而已，可以慢慢往上添。</p><p>看下面例子，区别就在于有无括号 <code>()</code>。</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> (*func_p)(<span class="hljs-keyword">double</span>);  <span class="hljs-comment">// 1</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">func_p</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;    <span class="hljs-comment">// 2</span></code></pre><ol><li>首先着眼于标识符 <code>func_p</code>；<br /><code>func_p is</code></li><li>对于 <code>1</code>，周围存在括号，所以 <code>*</code> 优先，<code>func_p</code> 是一个 <strong>指针</strong>；<br /><code>func_p is pointer to</code></li><li>解释完 <code>(*func_p)</code>，后面是表示函数的括号 <code>()</code> 以及参数 <code>double</code>；<br /><code>func_p is pointer to function(double) returning</code></li><li>数据类型是 <code>int</code>，完工。<br /><code>func_p is pointer to function(double) returning int</code></li></ol><p>而对于 <code>2</code>，不存在括号，所以按照优先级先解释表示函数的 <code>()</code>，所以 <code>func_p</code> 是一个函数，且参数为 <code>double</code>，返回值为 <code>int *</code>，即返回 <code>int</code> 型的指针变量。</p><p>所以按照上述方法，以下式子即可迎刃而解：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">float</span> *a[<span class="hljs-number">9</span>];<span class="hljs-keyword">float</span> (*a)[<span class="hljs-number">9</span>];</code></pre><p>第一个，很简单，写成以下形式秒秒钟明白：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">float</span> * a[<span class="hljs-number">9</span>];</code></pre><p><code>a</code> 是元素类型为 <code>float</code> 型指针的数组而已。</p><p>第二个，<code>a</code> 是个指针，指向一个数组（拥有 <code>9</code> 个 <code>float</code> 型的元素）。</p><p>如果不出意外的话，群魔乱舞的例子解释完了（n 级指针无需多言，当然理解和使用是两种概念）。</p><h3 id="函数声明"><a class="markdownIt-Anchor" href="#函数声明"></a> 函数声明</h3><p>我们来看前面出现过的 <code>signal()</code> 函数的原型声明：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">void</span> (*signal(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">int</span>)))(<span class="hljs-keyword">int</span>);</code></pre><ol><li>首先看标识符，语句中有两个标识符：<code>signal</code>、<code>sig</code> 和 <code>func</code>，明显可以知道后两者是作为函数参数，所以主体是 <code>signal</code></li><li>按照优先顺序，离标识符最近的是表示函数的括号 <code>()</code>，所以整个语句声明的是一个函数<ul><li>参数：除 <code>int</code> 型的 <code>sig</code>之外，还有<pre class="highlight"><code class="c"><span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">int</span>)</code></pre>分离之后就不难理解，<code>func</code> 是一个指针，指向一个函数（参数为 <code>int</code>、返回 <code>void</code>）</li><li>返回值：一个指针<pre class="highlight"><code class="c">*signal(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">void</span> (*func)(<span class="hljs-keyword">int</span>));</code></pre></li></ul></li><li>现在得到了一个指针，用标识符 <code>SIG</code> 替代，则整条语句转换为：<pre class="highlight"><code class="c"><span class="hljs-keyword">void</span> (*SIG)(<span class="hljs-keyword">int</span>);</code></pre>该指针指向一个函数（参数为 <code>int</code>、返回 <code>void</code>）</li></ol><p>类型链表示如下：</p><p><img src="https://s2.ax1x.com/2020/01/19/1Cjt81.png" alt="#b# 类型链表示" /></p><p><code>signal()</code> 函数是用于注册信号处理的函数，按照如下方式调用后，返回之前注册的处理当前信号中断的函数（这个函数显然得用指针来表示）。</p><pre class="highlight"><code class="c">signal(SIGSEGV, segv_handle);</code></pre><ul><li><code>SIGSEGV</code>：信号类型</li><li><code>segv_handle</code>：信号处理程序，就是传入的函数（的地址）</li></ul><p><code>signal()</code> 函数及 <code>segv_handle()</code> 都有相同的结构：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">void</span> (*a)(<span class="hljs-keyword">int</span>);</code></pre><p>因此，借助 <code>typedef</code>，可以使声明更加清晰：</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*<span class="hljs-keyword">sig_t</span>)</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-keyword">sig_t</span></span>;<span class="hljs-function"><span class="hljs-keyword">sig_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sig, <span class="hljs-keyword">sig_t</span> func)</span></span>;</code></pre><p><a href="#%E8%A7%A3%E8%AF%BB-c-%E5%A3%B0%E6%98%8E">解读 C 声明</a> 的引述中有这样一句话：</p><blockquote><p>为了把问题变得简单，我们在这里不考虑 <code>const</code> 和 <code>volatile</code>。</p></blockquote><p>关于 <code>volatile</code> 修饰符后续再讨论。<s>（因为我还没怎么接触到。）</s> 现在来看 <code>const</code> 修饰符。</p><h4 id="修饰符"><a class="markdownIt-Anchor" href="#修饰符"></a> 修饰符</h4><p>C 语言修饰符（specifier）包括但不限以下几个：</p><ul><li><code>inline</code></li><li><code>restrict</code></li><li>类型修饰符<ul><li><code>const</code></li><li><code>volatile</code></li></ul></li><li>存储类型修饰符<ul><li><code>auto</code></li><li><code>static</code></li><li><code>register</code></li><li><code>extern</code></li><li><code>typedef</code></li></ul></li></ul><p>关于这几个修饰符后续再讨论，在这里是为了明确类型修饰符和存储类型修饰符可以一起使用。</p><h4 id="const"><a class="markdownIt-Anchor" href="#const"></a> <em>const</em></h4><p><em>const</em> 可以将变量修饰为 <strong>只读</strong>，因此，常量就可以使用 <code>const</code> 来声明，<code>const</code> 也经常见于函数原型的参数列表。</p><p><code>strcpy()</code> 函数就是一个范例：</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src)</span></span>;</code></pre><p>此时，成为只读的不是 <code>src</code>，而是 <code>src</code> 所指向的对象</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">f_strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *src)</span></span>{    src = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">// success</span>    *src = <span class="hljs-string">"hhhhh"</span>; <span class="hljs-comment">// failed</span>}</code></pre><p><code>const</code> 修饰的是 <code>*src</code> 这一个整体，而不是 <code>src</code> 这个指针变量，即变量可以绑定其他地址。</p><p>如果要变量只读和都只读，可分别声明为如下形式（两处 <code>const</code> 都修饰了 <code>src</code>）：</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">f_strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *dst, <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> src)</span></span>{    src = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">// failed</span>    *src = <span class="hljs-string">"hhhhh"</span>; <span class="hljs-comment">// success</span>}<span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">f_strcpy</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *dst, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> src)</span></span>{    src = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">// falied</span>    *src = <span class="hljs-string">"hhhhh"</span>; <span class="hljs-comment">// failed</span>}</code></pre><p><code>const</code> 可以和 <code>char</code> 一起使用，排列组合一下，得到如下五种形式：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * p;<span class="hljs-keyword">const</span> * <span class="hljs-keyword">char</span> p;<span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> p;<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> * p;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> * p;</code></pre><p>定睛一看，<code>const * char p</code> 是个什么东西？去掉修饰符为 <code>* char p;</code>，根本不符合语法规范。其次，<code>const char * p</code> 和 <code>char const * p</code> 效果一样，所以只有以下三种形式：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * p;<span class="hljs-keyword">char</span> * <span class="hljs-keyword">const</span> p;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> * p;</code></pre><h3 id="再谈函数调用"><a class="markdownIt-Anchor" href="#再谈函数调用"></a> 再谈函数调用</h3><p><a href="#%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88">指向函数的指针</a> 一节提到，使用以下方式都可以成功调用：</p><pre class="highlight"><code class="c">func();(*func)();</code></pre><p>实际上，函数调用运算符 <code>()</code> 的对象是函数指针，而函数在表达式中会自动转换成指向函数的指针。如果对指向函数的指针解引用 <code>*</code>，会暂时成为函数，但因为在表达式中，又会变为指向函数的指针，因此 <code>*</code> 运算符发挥不了作用，以下函数可正常调用：</p><pre class="highlight"><code class="c">(**********<span class="hljs-built_in">printf</span>)(<span class="hljs-string">"hhhhhh"</span>);</code></pre><h3 id="void-0"><a class="markdownIt-Anchor" href="#void-0"></a> <code>(*(void (*)())0)()</code></h3><p>现在来解释封面的函数。某些运行于微处理器上的程序在启动计算机时，硬件将调用首地址为 <code>0</code> 的程序。为了模拟开机启动的情形，需要设计一个 C 语句，显式调用该程序，所以就有了这条语句。</p><pre class="highlight"><code class="c">(* (<span class="hljs-keyword">void</span> (*)()) <span class="hljs-number">0</span>)()</code></pre><p>假如有一个函数：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> (*func)(<span class="hljs-keyword">int</span>);</code></pre><p>可使用如下语句调用：</p><pre class="highlight"><code class="c">(*func)();</code></pre><p><code>func</code> 是指向函数的指针变量，即函数入口地址，那么这里入口地址是 <code>0</code>，但 <code>0</code> 不能作为函数指针，需要进行类型转换。</p><pre class="highlight"><code class="c"><span class="hljs-keyword">void</span> (*)()</code></pre><p>上式是一个指向返回值和参数都为空的函数的指针，可用来进行类型转换，转换之后如下：</p><pre class="highlight"><code class="c">(<span class="hljs-keyword">void</span> (*)()) <span class="hljs-number">0</span></code></pre><p>然后进行函数调用，得到最终的语句。</p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>读到这里，或许可以发现，以上内容部分概念有些许重复，因为 C 语言的指针和数组是类似的，却又不完全相同，尽管我极力想把结构理清楚，但概念就是这么零碎的存在，所以按照话题来论述也无妨，融会贯通才是最终目标。<s>实际上，《征服 C 指针》中也是分离各个话题的，造成很多概念提了又提的现象。</s> 文章题目仿自鲁迅先生的《关于章太炎先生二三事》，当然文章内容与原著无关。本文以 C 指针为主要对象，但记录的不只是指针，<s>（擒贼先擒王）</s>，而是围绕 C 语言一系列的坑与概念。</p><p>因为阅历和资历问题，我没法像《征服 C 指针》和《C 陷阱与缺陷》两位作者一样，援引经典文献，从历史根源出发讨论问题，因此我的论述从实验结果出发，我深知从现象看问题不可能全面，纰漏之处难免，还请各位不吝赐教。</p><p>其实后记的内容本该放在前言，但头重脚轻似乎不妥，所以放在这个不重要 <s>（看都不看）</s> 的角落。学习 C 语言是一辈子的事情，因此本文将持续更新，有必要时将会分解成系列文章。</p><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><ol><li>《征服 C 指针》</li><li>《C 陷阱与缺陷》</li><li><a href="https://zhuanlan.zhihu.com/p/85191629" target="_blank" rel="noopener" title="知乎专栏">神一般的C语言指针， 你看懂了多少？</a></li><li><a href="https://www.zhihu.com/question/66890284/answer/247582078" target="_blank" rel="noopener" title="知乎回答">C语言中-j—i怎样结合？ - vczh的回答 - 知乎</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 系统开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gmpy2 编译安装的坑</title>
      <link href="/2019/11/gmpy2-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%9A%84%E5%9D%91/"/>
      <url>/2019/11/gmpy2-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><blockquote><p>GMP，GNU Multiple Precision Arithmetic Library，GNU 高精度算术运算库</p></blockquote><p>gmpy2 是 <a href="https://www.python.org/" target="_blank" rel="noopener">Python</a> 的一个扩展库，常用在 CTF 的 Crypto 题中分解大素数。</p><ul><li><a href="https://github.com/aleaxit/gmpy" target="_blank" rel="noopener">Github</a></li><li><a href="https://pypi.org/project/gmpy2/" target="_blank" rel="noopener">PyPi</a></li><li><a href="https://gmpy2.readthedocs.io/en/latest/" target="_blank" rel="noopener">文档</a></li></ul><h2 id="tddr"><a class="markdownIt-Anchor" href="#tddr"></a> TD;DR</h2><p>本文记录 Kali 下编译安装 gmpy2 的过程，过程挺艰难，需要在网上爬很多帖，但后来发现，可以直接使用 apt 命令来安装，所以踩坑记录变成了部署记录。使用以下两条命令即可完成安装：</p><pre class="highlight"><code class="bash">$ apt install m4 libgmp-dev libmpfc-dev libmpc-dev$ pip3 install gmp2</code></pre><blockquote><p>APT 具有超级牛力。</p></blockquote><h2 id="编译环境"><a class="markdownIt-Anchor" href="#编译环境"></a> 编译环境</h2><p>好，所以现在开始编译安装。首先确保安装了 gcc 和 make。</p><pre class="highlight"><code class="bash">$ apt install gcc make</code></pre><ul><li>Kali：5.2.0-kali2-amd64u</li><li>GCC：8.3.0</li><li>Make：4.2.1</li></ul><h2 id="安装依赖库"><a class="markdownIt-Anchor" href="#安装依赖库"></a> 安装依赖库</h2><p>gmpy2 依赖 GMP、MPFR、MPC 三个库，需要提前安装。</p><p>为便于指定编译路径，先使用变量指定文件夹。</p><pre class="highlight"><code class="bash">$ mkdir -p <span class="hljs-variable">$HOME</span>/gmpy2$ GMPY=<span class="hljs-variable">$HOME</span>/gmpy2</code></pre><p>预先下载好所有依赖库的文件包，并解压，依次进入文件夹进行编译。</p><h3 id="m4"><a class="markdownIt-Anchor" href="#m4"></a> m4</h3><p><a href="http://ftp.gnu.org/gnu/m4/" target="_blank" rel="noopener" title="下载列表">m4</a> 是 <em>POSIX</em> 标准中的一部分，所有版本的 UNIX 下都可用。虽然这种语言可以单独使用，但大多数人需要 m4 仅仅是因为 GNU autoconf 中的 <em>configure</em> 脚本依赖它。</p><p>m4 模块最新版本是 <code>1.4.18</code>：</p><pre class="highlight"><code class="bash">$ v=1.4.18$ <span class="hljs-built_in">cd</span> m4-<span class="hljs-variable">${v}</span>$ ./configure -prefix=/usr/<span class="hljs-built_in">local</span>$ make &amp;&amp; make check &amp;&amp; make install</code></pre><h3 id="gmp"><a class="markdownIt-Anchor" href="#gmp"></a> GMP</h3><blockquote><p><a href="https://gmplib.org" target="_blank" rel="noopener" title="官网">GMP</a>，GNU Multiple Precision Arithmetic Library，GNU 高精度算术运算库</p></blockquote><p>GMP 提供了大量操作高精度大整数、浮点数的算术库，可直接使用，详细操作见 <a href="https://gmplib.org/gmp-man-6.1.0.pdf" target="_blank" rel="noopener" title="文档">官方文档</a>。</p><pre class="highlight"><code class="bash">$ v=6.1.2$ <span class="hljs-built_in">cd</span> gmp-<span class="hljs-variable">${v}</span>$ ./configure --prefix=<span class="hljs-variable">$GMPY</span> --<span class="hljs-built_in">enable</span>-static --<span class="hljs-built_in">disable</span>-shared --with-pic$ make &amp;&amp; make check &amp;&amp; make install</code></pre><h3 id="mpfr"><a class="markdownIt-Anchor" href="#mpfr"></a> MPFR</h3><blockquote><p>The MPFR library is a C library for multiple-precision floating-point computations with correct rounding. MPFR has continuously been supported by the INRIA and the current main authors come from the Caramba and AriC project-teams at Loria (Nancy, France) and LIP (Lyon, France) respectively; see more on the credit page. MPFR is based on theGMP multiple-precision library.</p></blockquote><p><a href="https://www.mpfr.org" target="_blank" rel="noopener" title="官网">MPFR</a> 是一个基于 GMP 库的高精度浮点计算库，因此需要先按照 GMP。</p><pre class="highlight"><code class="bash">$ v=4.0.2$ <span class="hljs-built_in">cd</span> mpfr-<span class="hljs-variable">${v}</span>$ ./configure --prefix=<span class="hljs-variable">$GMPY</span> --<span class="hljs-built_in">enable</span>-static --<span class="hljs-built_in">disable</span>-shared --with-pic --with-gmp=<span class="hljs-variable">$GMPY</span>$ make &amp;&amp; make check &amp;&amp; make install</code></pre><h3 id="mpc"><a class="markdownIt-Anchor" href="#mpc"></a> MPC</h3><p><a href="http://www.multiprecision.org/mpc/" target="_blank" rel="noopener">MPC</a></p><pre class="highlight"><code class="bash">$ v=1.1.0$ <span class="hljs-built_in">cd</span> mpc-<span class="hljs-variable">${v}</span>$ ./configure --prefix=<span class="hljs-variable">$GMPY</span> --<span class="hljs-built_in">enable</span>-static --<span class="hljs-built_in">disable</span>-shared --with-pic --with-gmp=<span class="hljs-variable">$GMPY</span> --with-mpfr=<span class="hljs-variable">$GMPY</span>$ make &amp;&amp; make check &amp;&amp; make install</code></pre><h2 id="安装-gmpy2"><a class="markdownIt-Anchor" href="#安装-gmpy2"></a> 安装 gmpy2</h2><p>使用安装脚本：</p><pre class="highlight"><code class="bash">$ python setup.py build --prefix=<span class="hljs-variable">$GMPY</span></code></pre><p>或者直接使用 pip：</p><pre class="highlight"><code class="">$ pip3 install gmpy2</code></pre><p>不出意外的话，到此就安装成功了。<s>但出了意外就还得爬帖了，（逃</s></p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://www.cnblogs.com/pcat/p/5746821.html" target="_blank" rel="noopener">gmpy2安装使用方法</a></li><li><a href="https://www.jianshu.com/p/0ab4b0d8facb" target="_blank" rel="noopener">python2/3 gmpy2库在linux下安装</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薛定谔的 Console.log()</title>
      <link href="/2019/09/%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84-Console-log/"/>
      <url>/2019/09/%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84-Console-log/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在写作本文时我已经理清了思路，但在当时走投无路、无计可施的情况下难免会忽略一些细节。复现问题时使用的是简单的例子，表现意思即可，故在此无需探讨例子的意义</p></blockquote><p>今天写代码时，调试一个数组对象，想把内容都打印出来，就直接 <code>console.log()</code>，把三角形展开，如下：</p><p><img src="https://s2.ax1x.com/2019/09/01/nptMD0.jpg" alt="" /></p><p>可以看到，<code>0:</code> 和 <code>1:</code> 对应的值都不是数组 <code>[]</code> 中的值，<code>0</code> 和 <code>1</code> 是数组的索引值，从 <code>0</code> 开始，没问题，但是为何对应的值不匹配呢？</p><p>在调试时，类似 <code>(2) [22, 2]</code> 行输出的是二维数组，因此输出不能一目了然，我认为没有预期输出是代码问题，因此审视了一遍代码，严格理了一遍逻辑发现并没有错误 <s>，除了一些小 Bug</s></p><p>走投无路时，发现有如下 <code>!</code> 的标记：</p><p><img src="https://s2.ax1x.com/2019/09/01/npJLWj.jpg" alt="" /></p><p>鼠标悬停，弹出如下提示：</p><p><img src="https://s2.ax1x.com/2019/09/01/npJqYQ.png" alt="" /></p><p>意识到可能这里存在“未解之谜”，<a href="https://www.bing.com" target="_blank" rel="noopener">Bing</a> 之后，发现果然存在玄机：<a href="https://segmentfault.com/a/1190000018831992" target="_blank" rel="noopener">记一次&quot;Value below was evaluated just now&quot;</a></p><p>我还是太年轻，<code>0</code>、<code>1</code>、<code>2</code>……输出的不是数组的值，而是最终改变的值，因此，在运行时展开，此时的值是展开那个时间点的值，就像封面图一样：</p><p><img src="https://s2.ax1x.com/2019/09/01/npJXSs.png" alt="" /></p><blockquote><p>当你在控制台展开打印出来的数组（或者对象）的时候，如果此时数组（或者对象）的数据已经发生了改变，那么将显示改变之后的数据。如果此时数组（或者对象）的数据没有发生改变，那么就一直显示此时的数据</p></blockquote><p>这个值不是固定的，而是视展开时的情况而定，就像电子双缝干涉实验所表现出来的，有无观察者会对结果产生影响</p><p><img src="http://tomcat.apache.org/res/images/tomcat.png" alt="Tomcat" /></p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack 踩坑记录</title>
      <link href="/2019/08/Webpack-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/08/Webpack-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>前段时间，学习了 <a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a>、<a href="https://ejs.co/" target="_blank" rel="noopener">EJS</a>、<a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a> 等工具，在学习 <a href="https://reactjs.org/" target="_blank" rel="noopener">React</a> 及其全家桶时，开始着手开发一些项目，以此巩固和提高。遂在之前一个已有项目的基础上，建立项目文件夹，项目结构如下：</p><pre class="highlight"><code class="">repo├── todo-list│  ├── webpack.config.js│  ├── screenshots│  ├── server│  ├── dist│  └── src│     ├── components│     ├── index.html│     ├── index.jsx│     ├── layout│     └── style├── package.json├── node_modules└── README.md</code></pre><p>其中，<code>repo</code> 为 Git 文件夹，除了 <code>todo-list</code> 这个文件夹以外还有其他项目文件夹，各个项目共用一个 <code>node_modules</code><s>，以节省空间</s></p><p>Webpack 入口（Entry）在 <code>index.jsx</code>，一般情况下，引用 <code>components</code> 文件夹下的 <code>container</code> 组件，代码应为：</p><pre class="highlight"><code class="js"><span class="hljs-keyword">import</span> Container <span class="hljs-keyword">from</span> <span class="hljs-string">'./layout/container'</span></code></pre><p><code>webpack.config.js</code> 配置如下：</p><pre class="highlight"><code class="js"><span class="hljs-keyword">const</span> ENTRY = path.join(__dirname, <span class="hljs-string">'src'</span>)<span class="hljs-keyword">const</span> OUTPUT = path.join(__dirname, <span class="hljs-string">'dist'</span>)<span class="hljs-built_in">module</span>.exports = {    <span class="hljs-attr">entry</span>: path.join(ENTRY, <span class="hljs-string">'index.jsx'</span>),    <span class="hljs-attr">output</span>: {        <span class="hljs-attr">path</span>: OUTPUT,        <span class="hljs-attr">filename</span>: <span class="hljs-string">'index.bundle.js'</span>,    }    <span class="hljs-comment">// ...</span>}</code></pre><p>构建运行，结果却是：</p><p><img src="https://s2.ax1x.com/2019/08/19/m3hly6.png" alt="" /></p><p>提示无法解析 <code>./layout/container</code>，猜测可能是相对于 Webpack 配置文件的路径，考虑到项目可能会扩大，因此添加 alias，并且修改 import 语句，</p><pre class="highlight"><code class="js"><span class="hljs-keyword">const</span> ENTRY = path.join(__dirname, <span class="hljs-string">'src'</span>)<span class="hljs-keyword">const</span> OUTPUT = path.join(__dirname, <span class="hljs-string">'dist'</span>)<span class="hljs-built_in">module</span>.exports = {    <span class="hljs-attr">entry</span>: path.join(ENTRY, <span class="hljs-string">'index.jsx'</span>),    <span class="hljs-attr">output</span>: {        <span class="hljs-attr">path</span>: OUTPUT,        <span class="hljs-attr">filename</span>: <span class="hljs-string">'index.bundle.js'</span>,    },    <span class="hljs-attr">resolve</span>: {<span class="hljs-attr">alias</span>: {<span class="hljs-string">"src"</span>: ENTRY}    }    <span class="hljs-comment">// ...</span>}</code></pre><p><s>此处的 <code>&quot;src&quot;: ENTRY</code> 似乎多此一举，但当时配置文件在 <code>repo</code> 文件夹，因此还有一个 <code>todo-list</code> 文件夹，路径更长</s></p><p>依旧报错……去掉 alias，还是报错，<em>How old are you？</em> 最后把组件和入口文件全部放在一起，还是报错……</p><p>意识到这应该不是路径的问题，可能是 Webpack 配置不对，再去翻文档，<a href="https://webpack.docschina.org/configuration/resolve/#resolve-alias" target="_blank" rel="noopener"><code>resolve.alias</code></a>，按照文档的意思，alias 配置没有问题，再去 <a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a>、<a href="https://www.bing.com/" target="_blank" rel="noopener">Bing</a> 搜索 alias 的用法，虽然大家写法不一，但总体和我是差不多的，但是 Webpack 似乎没有用上 alias 这一功能~~，虽然也看不出来，都是无法解析~~</p><p>最后搜索 <code>Module not found</code>，终于找到了些眉目：<a href="https://www.jianshu.com/p/f5d1d73fe414" target="_blank" rel="noopener">Module not found: Error: Can’t resolve ‘react’ in · 简书</a>，在这里，居然发现有 <code>resolve.modules</code> 这一项，山穷水复的情况下，拿来直接用，居然成功打包！！！</p><h2 id="以下为正文"><a class="markdownIt-Anchor" href="#以下为正文"></a> 以下为正文</h2><hr /><p>文档如下：</p><blockquote><p>resolve.modules<br /><code>[string]: ['node_modules']</code><br />告诉 webpack 解析模块时应该搜索的目录。<br />……<br />如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索</p></blockquote><p>该选项给出解析时的路径，默认是 <code>node_modules</code>，查找是会先从最近的 <code>node_modules</code> 目录里找，找不到则往上层找~~，因此，我之前共用一个包文件夹的设想是成功的~~</p><p><strong>可添加自定义的模块</strong>，路径应写在 <code>'node_modules'</code> 之前</p><hr /><p>因此，在这里，应配置为：</p><pre class="highlight"><code class="js"><span class="hljs-keyword">const</span> ENTRY = path.join(__dirname, <span class="hljs-string">'src'</span>)<span class="hljs-keyword">const</span> OUTPUT = path.join(__dirname, <span class="hljs-string">'dist'</span>)<span class="hljs-built_in">module</span>.exports = {    <span class="hljs-attr">entry</span>: path.join(ENTRY, <span class="hljs-string">'index.jsx'</span>),    <span class="hljs-attr">output</span>: {        <span class="hljs-attr">path</span>: OUTPUT,        <span class="hljs-attr">filename</span>: <span class="hljs-string">'index.bundle.js'</span>,    },    <span class="hljs-attr">resolve</span>: {        <span class="hljs-attr">extensions</span>: [<span class="hljs-string">'.js'</span>, <span class="hljs-string">'.jsx'</span>],        <span class="hljs-attr">modules</span>: [ENTRY, <span class="hljs-string">'node_modules'</span>]    }<span class="hljs-comment">// ...</span>}</code></pre><p>至于 alias 和 <code>index.js</code> 中的 import 语句，爱咋样咋样，保持原样即可</p>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IRC 浅尝</title>
      <link href="/2019/05/IRC-%E6%B5%85%E5%B0%9D/"/>
      <url>/2019/05/IRC-%E6%B5%85%E5%B0%9D/</url>
      
        <content type="html"><![CDATA[<p>不久前接触到 IRC，感觉很有意思，遂了解了一下，记录下来。最近 <a href="https://d3ctf.io/" target="_blank" rel="noopener">D^3CTF</a> 官方提供了一个 IRC 频道，想进去水一水，结果发现 IRC 不怎么会用了，在此检讨一下，重新学习。</p><p><img src="https://s1.ax1x.com/2019/11/19/MgOSB9.png" alt="#b# D^3CTF" title="#d^3ctf" /></p><h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><blockquote><p>因特网中继聊天（Internet Relay Chat，IRC）是一种历史悠久、应用广泛、成熟稳定的 <strong>网络即时通讯协议</strong>，被广泛地应用于在线通讯和网络聊天中。IRC 最早由芬兰人 <em>雅尔口·欧伊卡林恁</em>（Jarkko Oikarinen）于 1988 年 8 月创造以取代一个叫做 MUT 的程序，随后便一直在互联网中扮演重要角色。凡是支持互联网的操作系统，几乎都可以使用 IRC。虽然在 2003 年以后，许多功能更加丰富的聊天程序和服务取代了只能进行纯文字交流的 IRC，许多曾经的大型 IRC 服务器日渐式微，失去了 60% 的使用者。但对于许多应用来说，依然是一种方便可靠的通讯方式。（来自 <a href="https://zh.wikibooks.org/wiki/IRC" target="_blank" rel="noopener">Wikipedia</a>）</p></blockquote><p>我们有时会在电影里看到，黑客使用终端进行聊天，这似乎非常奇妙，<s>黑客可以用终端做任何事情</s> 就像下面这样。</p><p><img src="https://s1.ax1x.com/2019/11/20/MRdJjH.png" alt="#b# 《Mr.Reboot》截图" /></p><p>这是一种通讯方式，称为 IRC。</p><p>IRC 的实现方式，简言之，就是 IRC 用户使用 <strong>客户端</strong> 软件连接到 <strong>IRC 服务器</strong>，通过服务器 <strong>中继</strong> 与其他连接到这一服务器上的用户交流。</p><p>众所周知，A 与 B 可以直接进行通信，但 A、B 和 C 的通信则需要借助第三方 S 进行转发，如果参与到通信的人越来越多，则 S 的负担会越来越重。</p><p>因此如果有多个服务器，形成一张网络，服务器之间转发消息，用户只需要登录其中一个服务器，发送的消息就可以推送到各个用户节点。这一切通过互联网进行，因此称为 <em>互联网中继聊天</em>。</p><h3 id="聊天网络"><a class="markdownIt-Anchor" href="#聊天网络"></a> 聊天网络</h3><p>从一个 IRC 服务器可以连接其他服务器，由此构成一个网络。依据 IRC 协议组成的聊天网络，常见的有：</p><ul><li><a href="https://freenode.net" target="_blank" rel="noopener" title="主页"><em>freenode</em></a>：<a href="http://irc.freenode.net" target="_blank" rel="noopener">irc.freenode.net</a></li><li><em>EFnet</em>：<a href="http://www.efnet.org" target="_blank" rel="noopener">www.efnet.org</a></li><li><em>EFPer</em></li><li><em>DALnet</em></li></ul><p>大多数的 IRC 服务器不需要客户注册登录，但是在连接前必须设定好昵称（nickname）。</p><h3 id="频道"><a class="markdownIt-Anchor" href="#频道"></a> 频道</h3><p>频道的本质是广播室，相当于群组<s>聊天室</s>。</p><ul><li>单个 <code>#</code> 开头的频道表明这是一个和自由和开源软件项目有关的正式交流频道</li><li>两个 <code>#</code> 号开头的频道表明这是一个非官方、非正式，或和某个项目无关的自由讨论频道</li></ul><p>以下为几个较为活跃的频道 <s>2019 年未必日常活跃</s>：</p><ul><li><code>#wikipedia-zh</code>：中文维基百科交流使用的官方正式频道</li><li><code>#ubuntu-cn</code>：Ubuntu 中文社区频道</li><li><code>#linuxba</code>：Linux 贴吧频道</li><li><code>#haskell</code>：Haskell 语言频道</li><li><code>#c_lang_cn</code>：C 语言 IRC 频道</li><li><code>#vim</code>：Vim 社区频道</li><li><code>#openstack-chinese</code></li><li><code>#git</code></li><li><code>##javascript</code></li><li><code>#macosx</code></li><li><code>#ustc_lug</code></li><li><code>#kali</code></li><li><code>#debiancn</code></li><li><code>#osdev</code></li></ul><p>以下为几个官方的频道列表：</p><ul><li>KDE <a href="https://userbase.kde.org/IRC_Channels/zh-cn" target="_blank" rel="noopener">频道列表</a></li><li>Arch <a href="https://wiki.archlinux.org/index.php/Arch_IRC_channels" target="_blank" rel="noopener">频道列表</a></li><li>CentOS <a href="https://wiki.centos.org/zh/irc" target="_blank" rel="noopener">频道列表</a></li></ul><h3 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h3><p>传统的 IRC 是基于文本的，因此，<strong>图片</strong> 和表情则无法发送，若实在有必要，可使用图床等在线工具，这样一来只需发送图片链接即可。这里提供了几个网站可以张贴图片：</p><ul><li><a href="http://img.vim-cn.com/" target="_blank" rel="noopener">http://img.vim-cn.com/</a></li><li><a href="http://paste.edisonnotes.com/" target="_blank" rel="noopener">http://paste.edisonnotes.com/</a></li></ul><p>另外，类似 <strong>代码段</strong> 这样的长文本也不利于阅读，同样可以发到第三方平台进行共享。</p><ul><li><a href="http://dpaste.com/" target="_blank" rel="noopener">http://dpaste.com/</a></li><li><a href="http://paste.ubuntu.com/" target="_blank" rel="noopener">http://paste.ubuntu.com/</a></li></ul><p>需要注意，尽管 IRC 频道可加密，甚至可以自建服务器在其之上通信，可确保会话安全，但通讯线路并不加密，需要第三方软件或客户端实现加密，从这一角度上看，IRC 通信安全性并不高。</p><h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> 客户端</h2><p>接下来列举几个常见客户端</p><h3 id="pidgin"><a class="markdownIt-Anchor" href="#pidgin"></a> pidgin</h3><p>安装：</p><ol><li>macOS<pre class="highlight"><code class="bash">$ brew install adium</code></pre></li><li>Ubuntu<pre class="highlight"><code class="bash">$ apt install pidgin</code></pre></li><li>Windows 可去 <a href="http://pidgin.im/" target="_blank" rel="noopener">主页</a> 下载，注意需使用 offline 版本</li></ol><p>初次使用，需要在菜单-&gt;添加新的账户选择 IRC</p><p><img src="https://s1.ax1x.com/2019/11/19/MRkXbq.jpg" alt="添加账号" /></p><p>昵称任意，主机名可以填国内较快的 <code>irc.ubuntu.com</code></p><p>文件-&gt;加入群组聊天</p><p><img src="https://s1.ax1x.com/2019/11/19/MRkvV0.jpg" alt="加入聊天" /></p><p>填写 <a href="#%E9%A2%91%E9%81%93" title="跳转到频道章节">频道</a> 和密码（大多公共频道无密码）</p><p><img src="https://s1.ax1x.com/2019/11/19/MgOp7R.png" alt="adium 聊天界面" /></p><h3 id="textual"><a class="markdownIt-Anchor" href="#textual"></a> Textual</h3><p><a href="https://www.codeux.com/textual/" target="_blank" rel="noopener">主页</a></p><p>可免费全功能试用 30 天，到期后可功能有删减</p><p><img src="https://s1.ax1x.com/2019/11/19/M2YVkF.png" alt="Textual 聊天界面（现在太冷清了" /></p><h3 id="irssi"><a class="markdownIt-Anchor" href="#irssi"></a> Irssi</h3><p><a href="https://irssi.org" target="_blank" rel="noopener">主页</a><br /><a href="https://github.com/irssi/irssi" target="_blank" rel="noopener">GitHub</a></p><p>轻量级 CLI 客户端</p><p>安装：</p><ol><li>macOS<pre class="highlight"><code class="bash">$ brew install irssi</code></pre></li><li>Ubuntu<pre class="highlight"><code class="bash">$ apt install irssi</code></pre></li></ol><p>快捷键：</p><ul><li><kbd>Alt</kbd>+<kbd>1</kbd>/<kbd>2</kbd>/<kbd>3</kbd>：切换窗口</li><li><kbd>Alt</kbd>+<kbd>N</kbd>/<kbd>P</kbd>：滚动屏幕</li><li><kbd>PageUp</kbd>/<kbd>PageDown</kbd>：上下翻页</li></ul><p>配置文件：<code>~/.irssi/config</code></p><h4 id="常用命令"><a class="markdownIt-Anchor" href="#常用命令"></a> 常用命令</h4><ol><li>直接带昵称登录指定的服务器<pre class="highlight"><code class="bash">$ irrsi -c &lt;server&gt; [-p port -n nickname]</code></pre></li><li>登陆/退出 IRC 服务器<pre class="highlight"><code class="">/connect &lt;server&gt; [port]/disconnect &lt;server&gt;</code></pre></li><li>修改昵称<pre class="highlight"><code class="">/nick &lt;nickname&gt;</code></pre></li><li>进入频道<pre class="highlight"><code class="">/join &lt;#channel&gt; &lt;password&gt;</code></pre></li><li>查看窗口列表<pre class="highlight"><code class="">/window list</code></pre></li><li>关闭当前窗口<pre class="highlight"><code class="">/window close &lt;窗口编号&gt;</code></pre></li><li>退出应用<pre class="highlight"><code class="">/wc</code></pre></li></ol><h3 id="weechat"><a class="markdownIt-Anchor" href="#weechat"></a> WeeChat</h3><blockquote><p><a href="https://weechat.org" target="_blank" rel="noopener" title="主页">WeeChat</a>，Wee Enhanced Environment for Chat</p></blockquote><p>C 语言编写的 CLI 客户端，具有扩展性，支持 Python、Perl、Ruby</p><p>该项目仍在更新中，截稿时 <a href="https://weechat.org/download/," target="_blank" rel="noopener" title="下载页面">最新版</a> 为 v2.6（Sep 8, 2019）</p><p>安装：</p><ol><li>macOS<pre class="highlight"><code class="bash">$ brew install weechat</code></pre></li><li>Ubuntu<pre class="highlight"><code class="bash">$ apt install weechat screen</code></pre></li><li>Arch<pre class="highlight"><code class="bash">$ pacman -S weechat screen</code></pre></li></ol><ul><li>连接到服务器<pre class="highlight"><code class="irc">/connect freenode</code></pre></li></ul><p>自动连接到 freenode：</p><ol><li>添加一个 server<pre class="highlight"><code class="irc">/server add freenode &lt;chat.freenode.net&gt;</code></pre></li><li>设置自动连接到 freenode<pre class="highlight"><code class="irc">/set irc.server.freenode.autoconnect on</code></pre></li></ol><p><s>东西有点多，此处简单记下，日后慢慢体验（逃</s></p><h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3><ul><li><a href="https://www.mirc.com" target="_blank" rel="noopener">mIRC</a>：Windows 客户端<br /><img src="https://s1.ax1x.com/2019/11/19/M2YefJ.jpg" alt="#b# 图片来自网络" /><br /><img src="https://s1.ax1x.com/2019/11/19/M2Ynp9.jpg" alt="#b# 图片来自网络" /></li><li>irccloud：iOS/Android 客户端</li><li><a href="http://www.androirc.com/zh/" target="_blank" rel="noopener">AndroidIRC</a>：Android 客户端</li><li>Hexchat</li><li>xchat</li></ul><p><s>IRC 毕竟曾经火过，衍生产品不少，只不过大多较为古老罢了。</s></p><h2 id="常用命令-2"><a class="markdownIt-Anchor" href="#常用命令-2"></a> 常用命令</h2><p>RFC 规定了 IRC 命令规范，详询 <a href="https://en.wikipedia.org/wiki/List_of_Internet_Relay_Chat_commands" target="_blank" rel="noopener" title="维基百科">List of Internet Relay Chat commands</a></p><p><a href="https://wiki.ubuntu.org.cn/IRC%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">Ubuntu 中文</a> 给出了一些命令说明。</p><p>常见的 IRC 命令有以下几个，但不同平台的实现各有不同，具体需要参考相关说明。</p><p>注册频道、昵称等命令以 freenode 为例 <s>，毕竟目前（2019 年）稳定较为活跃的平台也就这么点</s>，该平台提供了一些服务，可用来进行操作，如：</p><ul><li>昵称操作使用 <code>NickServ</code></li><li>频道操作使用 <code>ChanServ</code></li></ul><p>其实相当于一个用户</p><p><img src="https://s1.ax1x.com/2019/11/19/M2YATU.png" alt="#b# ChanServ 管理员" /></p><p><a href="#irssi">irssi</a> 和 <a href="#weechat">Weechat</a> 等命令行界面常用命令大同小异，但各自又有不同，可简单参照 <s>，挖个坑，先把 GUI 玩好了，之后再把玩 CLI</s>。</p><h3 id="连接到网络"><a class="markdownIt-Anchor" href="#连接到网络"></a> 连接到网络</h3><p>连接到 IRC 服务器 <code>server</code></p><pre class="highlight"><code class="irc">/server &lt;server&gt;/connect &lt;server&gt;</code></pre><h3 id="频道-2"><a class="markdownIt-Anchor" href="#频道-2"></a> 频道</h3><h4 id="加入频道"><a class="markdownIt-Anchor" href="#加入频道"></a> 加入频道</h4><p>进入 <code>#channel</code> 频道</p><pre class="highlight"><code class="irc">/part &lt;#channel&gt;/join &lt;#channel&gt;</code></pre><h4 id="退出频道"><a class="markdownIt-Anchor" href="#退出频道"></a> 退出频道</h4><p>离开 <code>#channel</code> 频道，可留下离开的原因 <code>reason</code></p><pre class="highlight"><code class="irc">/quit &lt;#channel&gt; [reason]/leave &lt;#channel&gt;</code></pre><h4 id="暂时离开"><a class="markdownIt-Anchor" href="#暂时离开"></a> 暂时离开</h4><p>告诉别人暂时离开，当别人小窗你时将得到 <code>reason</code> 的消息</p><pre class="highlight"><code class="irc">/away &lt;reason&gt;</code></pre><h4 id="注册频道"><a class="markdownIt-Anchor" href="#注册频道"></a> 注册频道</h4><ol><li>进入（临时）频道 <code>#channel</code><pre class="highlight"><code class="irc">/join &lt;#channel&gt;</code></pre></li><li>设定密码<pre class="highlight"><code class="irc">/msg ChanServ register &lt;#channel&gt; &lt;password&gt;</code></pre></li></ol><h3 id="用户"><a class="markdownIt-Anchor" href="#用户"></a> 用户</h3><h4 id="注册昵称"><a class="markdownIt-Anchor" href="#注册昵称"></a> 注册昵称</h4><ol><li>更改密码为 <code>password</code>, 邮箱为 <code>me@gmail.com</code><pre class="highlight"><code class="irc">/msg ChanServ register &lt;password&gt; &lt;me@gmail.com&gt;</code></pre></li><li>登录：<pre class="highlight"><code class="irc">/msg ChanServ identify &lt;password&gt;</code></pre></li></ol><h4 id="更换昵称"><a class="markdownIt-Anchor" href="#更换昵称"></a> 更换昵称</h4><p>进入 IRC 服务器后，可修改昵称</p><pre class="highlight"><code class="irc">/nick &lt;newName&gt;</code></pre><h3 id="管理"><a class="markdownIt-Anchor" href="#管理"></a> 管理</h3><h4 id="查看信息"><a class="markdownIt-Anchor" href="#查看信息"></a> 查看信息</h4><ul><li>查看 <code>nick</code> 用户的信息<pre class="highlight"><code class="irc">/who &lt;nick&gt;</code></pre></li><li>查看 <code>IP</code> 登录<pre class="highlight"><code class="irc">/who &lt;IP&gt;</code></pre></li></ul><h4 id="踢出用户"><a class="markdownIt-Anchor" href="#踢出用户"></a> 踢出用户</h4><pre class="highlight"><code class="irc">/kick &lt;#channel&gt; &lt;nick&gt; &lt;reason&gt;</code></pre><h4 id="更改话题"><a class="markdownIt-Anchor" href="#更改话题"></a> 更改话题</h4><pre class="highlight"><code class="irc">/topic &lt;#channel&gt; &lt;topic&gt;</code></pre><hr /><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>以上就是 IRC 的大致情况和基本用法，相信仍有一些不当之处，欢迎指正。</p><p>可以看到，虽然 IRC 在现在的中国互联网已然没落，但因其简单、自由的性质，在极客圈中仍有不少追随者。IRC 服务器可作为一个节点加入 IRC 网络，因此，自建服务器也是可行的。得益于 IRC 协议的开放性，自建服务器也有多种方案，如 UnrealIRCd。</p><blockquote><p><a href="https://www.unrealircd.org" target="_blank" rel="noopener" title="主页">UnrealIRCd</a> is an Open Source IRC Server, serving thousands of networks since 1999.</p></blockquote><p>借助此项目建立私有的服务器，可使得信息不被不公开（首先得确保网络通信也是安全的）</p><p><s>想想也是挺有意思的，此处挖个坑，尝试自建一个 IRC 服务器。</s></p><p>在互联网通信高度发达的 9102 年，我在此挖掘几年甚至十几年前的技术似乎不合时宜，尽管如此，但 IRC 技术自身并非一无是处，某些特性甚至具有先进性，故仍具有其存在的意义。</p><h2 id="参考文章"><a class="markdownIt-Anchor" href="#参考文章"></a> 参考文章</h2><ol><li><a href="https://blog.csdn.net/john_cdy/article/details/7742218" target="_blank" rel="noopener">如何使用IRC</a></li><li><a href="https://www.cnblogs.com/tsdxdx/p/7291877.html" target="_blank" rel="noopener">命令行 IRC 客户端 irssi 的基本操作</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IRC </tag>
            
            <tag> 通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DPDK 工具</title>
      <link href="/2019/04/DPDK-%E5%B7%A5%E5%85%B7/"/>
      <url>/2019/04/DPDK-%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>DPDK 中提供了一些工具用来测试，本文对此进行一些简单的介绍，以期抛砖引玉。</p><ul><li>操作环境同上篇。虚拟机分配 4 个核心<ul><li>系统：CentOS 7 Kernel 3.10</li><li>架构：IA，64 位，4 核</li><li>内存：1 GB</li><li>DPDK 版本：18.11.1 LTS</li><li>网卡：使用 VirtualBox 虚拟机的 Intel 82540EM</li></ul></li><li>DPDK 提供的工具大多为实例，因此具有 EAL，在运行时需注意传入参数</li><li>大多实例需要两个以上核心，一个核用来管理命令行等信息，另外的核用来处理数据包</li><li>实例的运行可能需要 root 权限，建议使用 root 账户操作</li></ul><h2 id="testpmd"><a class="markdownIt-Anchor" href="#testpmd"></a> TestPMD</h2><ul><li>功能：在网络接口的以太网端口之间转发数据包。TestPMD 随 DPDK 库和工具一同编译，无需另外安装</li><li>路径：<code>&lt;RTE_SDK&gt;/&lt;RTE_TARGET&gt;</code>，此处为 <code>/dpdk/x86_64-native-linuxapp-gcc</code></li></ul><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>设置方式：</p><ul><li>将两个端口连接到外部流量生成器</li><li>使用回送模式下的两个端口接在一起</li></ul><p>转发模式：</p><ul><li>输入/输出：默认。通常称为 IO 模式，在内核接收一个端口的数据包（Rx）并将其传输到里一个端口（Tx）</li><li>仅 Rx：轮询来自 Rx 端口的数据包</li><li>仅 Tx：生成 64 字节的 IP 数据包并在 Rx 端口传输</li></ul><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><ol><li>设置 Hugepages、加载 UIO 驱动、绑定端口</li><li>运行程序。TestPMD 默认在非交互模式下运行，指定<code>-i</code> 可交互<pre class="highlight"><code class="bash">$ sudo /build/app/testpmd/<span class="hljs-built_in">test</span>-pmd –l 2,3,4 –n 4 -- -i</code></pre><ul><li><code>-l</code>：指定逻辑核心，核心 2 用于管理命令行，核心 3 和 4 将用于转发分组</li><li><code>-n</code>：指定系统的内存通道数</li></ul></li></ol><p>稍等片刻即可进入命令行交互界面。</p><h3 id="常用参数"><a class="markdownIt-Anchor" href="#常用参数"></a> 常用参数</h3><ul><li><code>--nb-cores=N</code>：设置转发核心数，其中 1≤N≤核心数，默认 1</li><li><code>--nb-ports=N</code>：设置转发端口的数量，其中 1≤N≤端口数</li><li><code>--coremask=0xXX</code>：设置转发测试核心的十六进制掩码。主 lcore 仅保留用于命令行解析</li><li><code>--portmask=0xXX</code>：设置转发测试的端口的十六进制掩码</li><li><code>--eth-peer=N,XX:XX:XX:XX:XX:XX</code>：设置端口 N 的 MAC 地址</li><li><code>--tx-ip=SRC,DST</code>：设置仅进行传输测试时使用的源和目的地址</li></ul><h3 id="常用运行时命令"><a class="markdownIt-Anchor" href="#常用运行时命令"></a> 常用运行时命令</h3><ul><li>检查配置<pre class="highlight"><code class="">show config fwd</code></pre></li><li>开始/停止 转发<pre class="highlight"><code class="">start / stop</code></pre></li><li>显示应用程序正在使用的所有端口的统计信息：<pre class="highlight"><code class="">show port stats all</code></pre></li><li>使用多个内核<pre class="highlight"><code class="">set nbcore 2</code></pre></li></ul><h2 id="pktgen-dpdk"><a class="markdownIt-Anchor" href="#pktgen-dpdk"></a> Pktgen-dpdk</h2><p>Pktgen-dpdk（Packet Generator）是一个基于 DPDK 开发的发包工具，因此也可以认为是一个实例，详询 <a href="https://pktgen-dpdk.readthedocs.io/en/latest/commands.html" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3><ol><li>安装 Lua <a href="https://www.lua.org/manual/5.3/readme.html" target="_blank" rel="noopener">文档</a><br />CentOS 7 所包含的 Lua 版本过低(5.1.x)，需要自行安装，此处使用 Lua 5.3.5<pre class="highlight"><code class="bash">$ <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/src$ wget http://www.lua.org/ftp/lua-5.3.5.tar.gz$ tar zxf lua-5.3.0.tar.gz$ <span class="hljs-built_in">cd</span> lua-5.3.0$ make &lt;platform&gt; install</code></pre><code>&lt;platform&gt;</code> 可选如下平台：<pre class="highlight"><code class="">aix bsd c89 freebsd generic linux macosx mingw posix solaris</code></pre>此处为 <code>linux</code></li><li>安装依赖<br />根据情况，CentOS 7 可能需要安装一些依赖才能编译，具体版本就不给出了<pre class="highlight"><code class="bash">$ yum install libpcap-dev$ yum install libreadline-dev</code></pre></li><li>设置环境变量<pre class="highlight"><code class="bash">$ <span class="hljs-built_in">export</span> RTE_SDK=~/dpdk$ <span class="hljs-built_in">export</span> RTE_TARGET=x86_64-native-linuxapp-gcc</code></pre></li><li>进入 pktgen 目录，编译<pre class="highlight"><code class="bash">$ <span class="hljs-built_in">cd</span> &lt;pktgen-dir&gt;$ make</code></pre></li></ol><h3 id="启动-2"><a class="markdownIt-Anchor" href="#启动-2"></a> 启动</h3><ol><li>可使用 <code>tools/run.py</code> 设置启动环境，该 Python 脚本尝试配置系统，内部有提权操作，因而不需要 <em>sudo</em>。<pre class="highlight"><code class="bash">$ ./tools/run.py default</code></pre>该命令需在 pktgen 顶级目录下运行，使用 <code>/cfg/default.cfg</code> 配置文件</li><li>启动<br />启动参数包含 EAL 和自身参数，用 <code>--</code> 分隔，将进入命令行<pre class="highlight"><code class="bash">$ sudo ./pktgen -l 0-1 -n 3 -- -P -T</code></pre>pktgen 需要至少两个逻辑内核才能运行</li></ol><h3 id="常用参数-2"><a class="markdownIt-Anchor" href="#常用参数-2"></a> 常用参数</h3><ul><li><code>-f</code>：指定脚本，<code>.pkt</code> 或 <code>.lua</code></li><li><code>-l</code>：指定日志文件</li><li><code>-p</code>：指定端口</li><li><code>-P</code>：在所有端口启用混杂模式</li><li><code>-T</code>：彩色终端输出</li><li><code>-G</code>：启用 socket</li><li><code>-N</code>：启用 NUMA 支持</li><li><code>-s&lt;P&gt;:&lt;file&gt;</code>：要传输的端口和 PCAP 文件</li><li><code>-m &lt;string&gt;</code>：将端口映射到核心<ul><li><code>:</code> 表示分别</li><li><code>-</code> 表示和</li><li>[Core].[Port]</li><li>[rx:tx]</li></ul><pre class="highlight"><code class="">1.0, 2.1, 3.2[1:2].0[1:2].[0-1]</code></pre></li></ul><h3 id="常见运行时命令"><a class="markdownIt-Anchor" href="#常见运行时命令"></a> 常见运行时命令</h3><ul><li>set<pre class="highlight"><code class="">set &lt;portlist&gt; &lt;command&gt; value</code></pre><ul><li>command 参数：<ul><li><code>count</code>：发送报文的数量</li><li><code>size</code>：报文大小</li><li><code>rate</code>：发送报文的速率</li><li><code>sport</code>：TCP 源端口号</li><li><code>dport</code>：TCP 目的端口号</li></ul></li><li>也可设置 MAC 及 IP<pre class="highlight"><code class="">set mac &lt;portlist&gt; &lt;ethaddr&gt;set ip src|dst &lt;portlist&gt; &lt;ipaddr&gt;</code></pre></li></ul></li><li>seq：发送报文信息<pre class="highlight"><code class="">seq &lt;seq#&gt; &lt;portlist&gt; dst_mac src_mac dst_ip src_ip sport dport ipv4|ipv6|vlan udp|tcp|icmp vid pktsize</code></pre></li><li>save/load：保存/导入当前配置到文件</li></ul><h2 id="pktgen"><a class="markdownIt-Anchor" href="#pktgen"></a> Pktgen</h2><p>pktgen 是一个位于 Linux 内核层的高性能网络测试工具，支持多线程，能产生随机 MAC 地址、IP 地址、UDP 端口号等信息的数据包。</p><ul><li>Linux 发行版默认包含</li><li>pktgen 的配置与统计信息查看都使用 <code>/proc</code> 文件系统的数据写入功能</li></ul><h3 id="启动-3"><a class="markdownIt-Anchor" href="#启动-3"></a> 启动</h3><ol><li>加载内核<pre class="highlight"><code class="bash">$ modprobe pktgen</code></pre>在 <code>/proc/net/pktgen</code> 可看见如下内容，文件数由 CPU 决定：<pre class="highlight"><code class="">kpktgend_0  kpktgend_1  kpktgend_2  kpktgend_3  pgctrl</code></pre></li><li>手动运行命令<pre class="highlight"><code class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"rem_device_all"</span> &gt; /proc/net/pktgen/kpktgend_0<span class="hljs-built_in">echo</span> <span class="hljs-string">"add_device eth0"</span> &gt; /proc/net/pktgen/kpktgend_0<span class="hljs-built_in">echo</span> <span class="hljs-string">"pkt_size 1000"</span> &gt; /proc/net/pktgen/eth0<span class="hljs-built_in">echo</span> <span class="hljs-string">"count 1000"</span> &gt; /proc/net/pktgen/eth0<span class="hljs-built_in">echo</span> <span class="hljs-string">"delay 1"</span> &gt; /proc/net/pktgen/eth0<span class="hljs-built_in">echo</span> <span class="hljs-string">"src 10.180.80.179"</span> &gt; /proc/net/pktgen/eth0<span class="hljs-built_in">echo</span> <span class="hljs-string">"dst 10.180.80.181"</span> &gt; /proc/net/pktgen/eth0<span class="hljs-built_in">echo</span> <span class="hljs-string">"start"</span> &gt; /proc/net/pktgen/pgctrl</code></pre><ul><li><code>pkt_size</code>：包长</li><li><code>count</code>：发包个数</li><li><code>delay</code>：时间间隔，单位是纳秒</li></ul></li><li>也可使用命令构建脚本</li></ol><h3 id="常见命令"><a class="markdownIt-Anchor" href="#常见命令"></a> 常见命令</h3><h4 id="控制命令"><a class="markdownIt-Anchor" href="#控制命令"></a> 控制命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>start</td><td>所有线程开始发送</td></tr><tr><td>stop</td><td>停止</td></tr></tbody></table><h4 id="线程的控制命令"><a class="markdownIt-Anchor" href="#线程的控制命令"></a> 线程的控制命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>add_device</td><td>添加某个端口到某个线程</td></tr><tr><td>rem_device_all</td><td>删除绑定在某个线程的所有端口</td></tr><tr><td>max_before_softirq</td><td>在最多发送多少个数据包后,执行 do_softirq()</td></tr></tbody></table><h4 id="端口命令"><a class="markdownIt-Anchor" href="#端口命令"></a> 端口命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>debug</td><td>调试</td></tr><tr><td>clone_skb</td><td>对每个 skb 进行多少个复制，0 表示不复制</td></tr><tr><td>clear_counters</td><td>清空计数器，默认自动清空</td></tr><tr><td>pkt_size</td><td>链路包的大小（除去CRC的值）</td></tr><tr><td>min_pkt_size</td><td>数据包最小值</td></tr><tr><td>max_pkt_size</td><td>数据包最大值</td></tr><tr><td>flags</td><td>包的分片数量</td></tr><tr><td>count</td><td>发送数据包的个数，0 表示一直发送</td></tr><tr><td>delay</td><td>发送两个数据包之间的延时</td></tr><tr><td>dst</td><td>目的 IP</td></tr><tr><td>dst_min</td><td>目的 IP 的最小值</td></tr><tr><td>dst_max</td><td>目的 IP 的最大值</td></tr><tr><td>src_min</td><td>源 IP 最小值</td></tr><tr><td>src_max</td><td>源 IP 最大值</td></tr><tr><td>dst6</td><td>目的 IPv6 地址</td></tr><tr><td>src6</td><td>源 IPv6 地址</td></tr><tr><td>dstmac</td><td>目的 MAC</td></tr><tr><td>srcmac</td><td>源 MAC</td></tr><tr><td>src_mac_count</td><td>源 MAC 的数量，从 srcmac 的 MAC 开始轮询</td></tr><tr><td>dst_mac_count</td><td>目的 MAC 的数量，从 srcmac 的 MAC 开始轮询</td></tr><tr><td>udp_src_min</td><td>最小源 UDP 端口号</td></tr><tr><td>udp_src_max</td><td>最大源 UDP 端口号</td></tr><tr><td>udp_dst_min</td><td>最小目的 UDP 端口号</td></tr><tr><td>udp_dst_max</td><td>最大目的 UDP 端口号</td></tr><tr><td>flows</td><td>并发流的个数</td></tr><tr><td>flowlen</td><td>流的长度</td></tr></tbody></table><h4 id="flags"><a class="markdownIt-Anchor" href="#flags"></a> Flags</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>IPSRC_RND</td><td>PSRC_RND 源 IP 随机发送</td></tr><tr><td>IPDST_RND</td><td>IPDST_RND 源 IP 随机发送</td></tr><tr><td>TXSIZE_RND</td><td>YXSIZE_RND 源 IP 随机发送</td></tr><tr><td>UDPSRC_RND</td><td>UDPSRC_RND 源 IP 随机发送</td></tr><tr><td>UDPDST_RND</td><td>UDPDST_RND 源 IP 随机发送</td></tr><tr><td>MACSRC_RND</td><td>MACSRC_RND 源 IP 随机发送</td></tr><tr><td>MACDST_RND</td><td>MACDST_RND 源 IP 随机发送</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 系统开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DPDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 语法</title>
      <link href="/2019/04/Markdown-%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/04/Markdown-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2><p>本文不是 Markdown 入门教程，而是收录各种 Markdown 编辑器的语法及快捷键，方便查询和扩展</p><p>目前整理收录了以下语法：</p><ul><li>GitHub</li><li>有道云笔记</li><li>VSCode 的 Markdown Preview Enhanced</li><li>VSCode 的 Markdown All in One</li></ul><h2 id="常用语法"><a class="markdownIt-Anchor" href="#常用语法"></a> 常用语法</h2><h3 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h3><ol><li>使用 N 个 <code>#</code> 表示 N 级标题，填上空格，可闭合</li><li>类 Setext：<code>=</code> 最高阶标题；<code>-</code> 第二阶标题</li></ol><h3 id="斜体"><a class="markdownIt-Anchor" href="#斜体"></a> 斜体</h3><p>内容两端使用 <code>*</code>，且不加空格，即 HTML 中的 <code>&lt;em&gt;</code><br /><code>*内容*</code> --&gt; <em>内容</em></p><h3 id="粗体"><a class="markdownIt-Anchor" href="#粗体"></a> 粗体</h3><p>内容两端使用 <code>*</code>，且不加空格，即 HTML 中的 <code>&lt;strong&gt;</code><br /><code>**文字</code> --&gt; <strong>文字</strong></p><h3 id="删除线"><a class="markdownIt-Anchor" href="#删除线"></a> 删除线</h3><p>内容两端使用 <code>~~</code>，且不加空格<br /><code>~~Word~~</code> --&gt; <s>Word</s></p><h3 id="分割线"><a class="markdownIt-Anchor" href="#分割线"></a> 分割线</h3><ul><li>使用三个及以上的 <code>*</code>/<code>-</code>/<code>_</code></li></ul><hr /><h2 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h2><h3 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h3><ul><li>使用 <code>*</code>/<code>+</code>/<code>-</code>，符号和内容空一格 <code></code></li></ul><h3 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h3><ul><li>数字加点<code>.</code>，空一格 <code></code>再填写内容，可嵌套 Markdown 语法</li></ul><pre class="highlight"><code class="markdown"><span class="hljs-bullet">1. </span>A<span class="hljs-bullet">    1. </span>a<span class="hljs-bullet">    2. </span>b<span class="hljs-bullet">    - </span>c<span class="hljs-bullet">2. </span>B</code></pre><p>显示如下：</p><ol><li>A<ol><li>a</li><li>b</li></ol><ul><li>b</li></ul></li><li>B</li></ol><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><ul><li>使用 <code>&gt;</code> 表示说明的文本</li><li>可多层嵌套 Markdown 语法</li></ul><pre class="highlight"><code class="markdown"><span class="hljs-quote">&gt; This is quote</span><span class="hljs-quote">&gt; &gt; This is *quote* in quote</span></code></pre><p>显示如下：</p><blockquote><p>This is quote</p></blockquote><blockquote><blockquote><p>This is <em>quote</em> in quote</p></blockquote></blockquote><h3 id="嵌套缩进"><a class="markdownIt-Anchor" href="#嵌套缩进"></a> 嵌套缩进</h3><p><a href="#%E5%88%97%E8%A1%A8">列表</a>与<a href="#%E5%BC%95%E7%94%A8">引用</a>的嵌套语法相同</p><ul><li>列表多段落用 1~3 空格 <code></code> 或 1 Tab</li><li>列表内引用 <code>&gt;</code> 缩进 1 次</li><li>列表内引用代码缩进 2 次</li></ul><h2 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h2><h3 id="行内式"><a class="markdownIt-Anchor" href="#行内式"></a> 行内式</h3><ul><li><code>[]</code> 内注明显示的文本</li><li><code>()</code> 内填写 URI，可以是本文档的内容</li><li><code>&quot; &quot;</code> 内填写鼠标悬停时的说明，需与链接空一格</li></ul><p>代码</p><pre class="highlight"><code class="markdown">This is [<span class="hljs-string">Bing</span>](<span class="hljs-link">http://www.bing.com/ "Bing"</span>)</code></pre><p>显示为：<br />This is <a href="http://www.bing.com/" target="_blank" rel="noopener" title="Bing">Bing</a></p><h3 id="参考式"><a class="markdownIt-Anchor" href="#参考式"></a> 参考式</h3><ul><li>在文件的 <strong>任意</strong> 处，定义标记的链接内容</li><li>用 ID 作为索引，可以是数字、文本符号</li><li><code></code>（title）可放到下一行，也可以缩进</li></ul><p>This is <a href="http://www.bing.com/" target="_blank" rel="noopener" title="Bing">Bing</a></p><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ol><li>在文章前填写 <code>[TOC]</code></li><li>使用 <a href="%E5%88%97%E8%A1%A8">列表</a> 加 <a href="#%E9%93%BE%E6%8E%A5">链接</a> 的形式</li><li>MPE：在任意位置插入 <code>&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false} --&gt;</code></li></ol><h3 id="注脚"><a class="markdownIt-Anchor" href="#注脚"></a> 注脚</h3><ul><li>使用 <code>[^ID]</code> 表示注脚</li></ul><pre class="highlight"><code class="markdown"><span class="hljs-bullet">1. </span>一个注脚[^footnote]的样例<span class="hljs-bullet">2. </span>第二个注脚[^footnote2]的样例</code></pre><p>显示为：</p><ol><li>一个注脚<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的样例</li><li>第二个注脚<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>的样例</li></ol><h2 id="图像"><a class="markdownIt-Anchor" href="#图像"></a> 图像</h2><h3 id="uri"><a class="markdownIt-Anchor" href="#uri"></a> URI</h3><pre class="highlight"><code class="markdown">![<span class="hljs-string">描述</span>](<span class="hljs-link">URI "悬停时的注释"</span>)</code></pre><ul><li><code>描述</code> 为网络出错时的文字叙述</li><li>URI 之后空一格，填写鼠标悬停时的注释</li><li><code>URI</code> 可以为网络资源，也可以是本地图片</li></ul><h3 id="base64"><a class="markdownIt-Anchor" href="#base64"></a> <em>base64</em></h3><pre class="highlight"><code class="markdown"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"data:img/扩展名;base64,base64编码"</span> /&gt;</span></span></code></pre><p>因 <em>Base64</em> 较长，故可用<a href="#%E5%8F%82%E8%80%83%E5%BC%8F">参考式</a>的方式将 <em>Base64</em> 字符串置于文章末尾</p><h3 id="img-标签"><a class="markdownIt-Anchor" href="#img-标签"></a> <code>&lt;img&gt;</code> 标签</h3><p>Markdown 兼容 <em>HTML</em> 标记语言，可使用 <em>HTML</em> 的 <code>div</code> 标签</p><ul><li>大小<pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">width</span> = <span class="hljs-string">"300"</span> <span class="hljs-attr">height</span> = <span class="hljs-string">"200"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"图片名称"</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span> /&gt;</span></code></pre></li><li>居中<pre class="highlight"><code class="css">&lt;<span class="hljs-selector-tag">div</span>  <span class="hljs-selector-tag">align</span>="<span class="hljs-selector-tag">center</span>"&gt;...&lt;/<span class="hljs-selector-tag">div</span>&gt;</code></pre></li></ul><h2 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h2><ol><li>行内代码块：`</li><li>非代码：```</li><li>代码块：<ol><li>4 空格 或 1 Tab 缩进</li><li>1 对 ``` 跨行引用</li></ol></li></ol><h3 id="扩展语法"><a class="markdownIt-Anchor" href="#扩展语法"></a> 扩展语法</h3><ol><li>语法高亮：在代码块前的 ``` 行注明</li><li>行号显示:<code>{class:&quot;line-numbers&quot;}</code></li></ol><h2 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h2><p>基于 HTML，可以用相关 <code>&lt;table&gt;</code> 标签创建多种样式</p><ul><li>用 <code>|</code>、<code>-</code>标记表格</li><li>栏与栏间用 <code>|</code></li><li>标题行与数据行用 <code>-</code> 分隔</li></ul><h3 id="markdown"><a class="markdownIt-Anchor" href="#markdown"></a> Markdown</h3><pre class="highlight"><code class="Markdown">| 项目   | 价格   | 数量 || ----- | ------ | ---- || 手机   | \$12   | 12   || 管线   | \$1    | 234  |</code></pre><p>显示为：</p><table><thead><tr><th>项目</th><th>价格</th><th>数量</th></tr></thead><tbody><tr><td>手机</td><td>$12</td><td>12</td></tr><tr><td>管线</td><td>$1</td><td>234</td></tr></tbody></table><h3 id="html"><a class="markdownIt-Anchor" href="#html"></a> HTML</h3><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>项目<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>价格<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>计算机<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$1600<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span></code></pre><p>显示为：</p><table>    <tr>        <th>项目</th>        <th>价格</th>        <th>星期</th>    </tr>    <tr>        <td>计算机</td>        <td>$1600</td>        <td>5</td>    </tr>    <tr>        <td>移动硬盘</td>        <td>$80</td>        <td>50</td>    </tr></table><h2 id="todo-列表"><a class="markdownIt-Anchor" href="#todo-列表"></a> Todo 列表</h2><ul><li><code>[ ]</code>（未完成）或 <code>[x]</code>（已完成）</li><li>支持子列表嵌套 Markdown 语法</li></ul><pre class="highlight"><code class="markdown"><span class="hljs-bullet">- </span>[ ] <span class="hljs-strong">**Markdown 开发**</span><span class="hljs-bullet">    - </span>[ ] 支持以 PDF 格式导出文稿<span class="hljs-bullet">    - </span>[x] 新增 Todo 列表功能<span class="hljs-bullet">    - </span>[x] 改进 LaTex 功能<span class="hljs-bullet">        - </span>[x] 修复 LaTex 公式渲染问题<span class="hljs-bullet">        - </span>[x] 新增 LaTex 公式编号功能<span class="hljs-bullet">- </span>[ ] <span class="hljs-strong">**七月旅行准备**</span><span class="hljs-bullet">    - </span>[ ] 准备邮轮上需要携带的物品<span class="hljs-bullet">    - </span>[x] 购买七月一日的船票</code></pre><p>显示如下：</p><ul><li>[ ] <strong>Markdown 开发</strong><ul><li>[ ] 支持以 PDF 格式导出文稿</li><li>[x] 新增 Todo 列表功能</li><li>[x] 改进 LaTex 功能<ul><li>[x] 修复 LaTex 公式渲染问题</li><li>[x] 新增 LaTex 公式编号功能</li></ul></li></ul></li><li>[ ] <strong>七月旅行准备</strong><ul><li>[ ] 准备邮轮上需要携带的物品</li><li>[x] 购买七月一日的船票</li></ul></li></ul><h3 id="转义"><a class="markdownIt-Anchor" href="#转义"></a> 转义</h3><ul><li><p>使用反斜线 <code>/</code>，以下内容可能需转义：</p><ol><li>\：反斜线</li><li>`：反引号</li><li>*：星号</li><li>_：底线</li><li>{}：花括号</li><li>[]：方括号</li><li>()：括弧</li><li>#：井字号</li><li>+：加号</li><li>-：减号</li><li>.：英文句点</li><li>!：惊叹号</li></ol></li><li><p><code>&lt;</code>：<code>&amp;lt;</code></p></li><li><p><code>&amp;</code>：<code>&amp;amp;</code></p></li><li><p>©：<code>&amp;copy;</code></p></li></ul><h3 id="首行缩进"><a class="markdownIt-Anchor" href="#首行缩进"></a> 首行缩进</h3><ul><li>半方大的空白<code>&amp;ensp;</code>或<code>&amp;#8194</code></li><li>全方大的空白<code>&amp;emsp;</code>或<code>&amp;#8195</code></li><li>不断行的空白格<code>&amp;nbsp;</code>或<code>&amp;#160</code></li></ul><h2 id="扩展语法-2"><a class="markdownIt-Anchor" href="#扩展语法-2"></a> 扩展语法</h2><p><em>Visual Studio Code</em> 插件 Markdown Preview Enhanced</p><ol><li>目录：<ol><li>在任意位置插入 <code>&lt;!-- @import &quot;[TOC]&quot; {cmd=&quot;toc&quot; depthFrom=2 depthTo=3 orderedList=false} --&gt;</code></li><li>代码<pre class="highlight"><code class="markdown">---toc:<span class="hljs-code">    depth_from:2</span><span class="hljs-code">    depth_to:4</span><span class="hljs-section">    ordered:false---</span></code></pre></li></ol></li><li>批注：<ol><li><mark>高亮：</mark> <code>== ==</code></li><li>注释：{&gt;&gt;注释&lt;&lt;}</li><li>下划线：{<ins>下划线内容</ins>}</li></ol></li><li>表格<ul><li><code>^</code> 向上合并单元格，<code>&gt;</code> 向右合并单元格</li></ul></li><li>在文档里运行代码</li><li>导入文件：<code>@import &quot;file&quot;</code></li></ol><hr class="footnotes-sep" /><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>这是一个 <em>注脚</em> 的 <strong>文本</strong>。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>这是另一个 <em>注脚</em> 的 <strong>文本</strong>。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Geek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 参考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DPDK 部署</title>
      <link href="/2019/04/DPDK-%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/04/DPDK-%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><blockquote><p><a href="https://www.dpdk.org/" target="_blank" rel="noopener">DPDK</a> is the Data Plane Development Kit that consists of libraries to accelerate packet processing workloads running on a wide variety of CPU architectures.</p></blockquote><p>最近用到 <em>Intel©️DPDK</em>，即 Intel Data Plane Development Kit，<a href="http://doc.dpdk.org/guides/index.html" target="_blank" rel="noopener">官方文档</a> 挺全面，但是一路跟下来，问题并不少；同时，该工具包本身不是像 ZSH 那样一般常见且常用的工具，各大平台上相关的资料并不算多。故在此将学习的过程记录下来，希望能起到抛砖引玉的作用。</p><h2 id="部署"><a class="markdownIt-Anchor" href="#部署"></a> 部署</h2><h3 id="环境"><a class="markdownIt-Anchor" href="#环境"></a> 环境</h3><ul><li>系统：CentOS 7 Kernel 3.10</li><li>架构：IA，64 位</li><li>内存：1 GB</li><li>DPDK 版本：18.11.1 LTS</li><li>网卡：使用 VirtualBox 虚拟机的 Intel 82540EM</li></ul><p>目录结构如下：</p><pre class="highlight"><code class="">dpdk-18.11.1├── app├── devtools├── doc├── examples├── kernel├── drivers├── lib├── buildtools├── config├── mk├── license├── pkg├── test└── usertools</code></pre><h3 id="安装条件"><a class="markdownIt-Anchor" href="#安装条件"></a> 安装条件</h3><ol><li>硬件支持，查询 <a href="http://core.dpdk.org/supported/" target="_blank" rel="noopener">网卡支持</a></li><li>查看 CPU 是否支持大页内存技术<pre class="highlight"><code class="bash">$ grep flags /proc/cpuinfo</code></pre><ul><li>包含 pge 表示支持 2MB 大页内存</li><li>包含 pdpe1gb 表示支持 1GB 大页内存</li></ul></li><li>查看内存分页情况：<pre class="highlight"><code class="bash">$ grep Huge /proc/meminfo</code></pre></li><li>安装必要依赖<pre class="highlight"><code class="bash">$ yum install numactl-devel*x86_64</code></pre></li></ol><p>更具体的信息在 <a href="http://doc.dpdk.org/guides/linux_gsg/sys_reqs.html" target="_blank" rel="noopener">官方文档</a> 中</p><h3 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h3><ol><li><p>设置环境变量<br />将以下内容增加到 <code>~/.bash_profile</code> 或 <code>~/.zshrc</code> 等 <em>shell</em> 配置文件，或者直接输入：</p><pre class="highlight"><code class="bash"><span class="hljs-built_in">export</span> DPDK_DIR=&lt;DPDK-DIR&gt;<span class="hljs-built_in">export</span> DPDK_TARGET=&lt;TARGET&gt;<span class="hljs-built_in">export</span> DPDK_BUILD=<span class="hljs-variable">$DPDK_DIR</span>/<span class="hljs-variable">$DPDK_TARGET</span></code></pre><p><code>TARGET</code> 格式为 <code>ARCH-MACHINE-EXECENV-TOOLCHAIN</code></p><ul><li>ARCH: i686，x86_64，ppc_64，arm64</li><li>MACHINE: native，power8，armv8a</li><li>EXECENV: linux，freebsd</li><li>TOOLCHAIN: gcc，icc</li></ul><p>带入变量，命令如下：</p><pre class="highlight"><code class="bash">$ <span class="hljs-built_in">export</span> DPDK_DIR=/root/dpdk$ <span class="hljs-built_in">export</span> DPDK_TARGET=x86_64-native-linuxapp-gcc</code></pre></li><li><p>编译</p><pre class="highlight"><code class="bash">$ make install T=&lt;TARGET&gt;   <span class="hljs-comment"># T 指定编译的目标环境</span>$ make install T=x86_64-native-linuxapp-gcc</code></pre><p>将提示 <code>Installation cannot run with T defined and DESTDIR undefined</code>，即未指定安装位置，此处只需编译，可忽略，目录下多了名为 <code>&lt;TARGET&gt;</code> 的文件夹</p></li></ol><h3 id="目录结构"><a class="markdownIt-Anchor" href="#目录结构"></a> 目录结构</h3><pre class="highlight"><code class="">x86_64-native-linuxapp-gcc    # 即指定的 &lt;TARGET&gt;├── app├── build├── include├── kmod        # 存放内核模块├── lib└── Makefile</code></pre><h2 id="启动环境"><a class="markdownIt-Anchor" href="#启动环境"></a> 启动环境</h2><p>DPDK 可总结如下：</p><ul><li>UIO，Userspace I/O</li><li>Hugepages</li><li>CPU Affinity 机制</li></ul><p>其中一些特性的实现还需要系统环境支持，可使用 DPDK 提供的 <code>usertools/dpdk-setup.sh</code> 脚本来配置</p><h3 id="hugepages"><a class="markdownIt-Anchor" href="#hugepages"></a> hugepages</h3><p>为支持 Hugepages，需要配置内存页。</p><ul><li>若仅使用 2MiB 大页内存<br />输入以下命令，比较灵活方便，但是每次启动都要操作：<pre class="highlight"><code class="bash">$ sudo <span class="hljs-built_in">echo</span> 1024 &gt; /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages</code></pre></li><li>若使用 VFIO<br />添加以下内容到 <code>/etc/default/grub</code> 的 <code>GRUB_CMDLINE_LINUX</code>：<pre class="highlight"><code class="">hugepages=1024  # 对于 2MiB 页面default_hugepagesz=1G hugepagesz=1G hugepages=4 iommu=pt intel_iommu=on</code></pre>更新 grub 并重启<pre class="highlight"><code class="bash">$ grub2-mkconfig -o /boot/grub2/grub.cfg</code></pre></li><li>若使用 igb_uio<br />可不开启 <code>iommu</code> 的两个选项</li></ul><p>设置完内存页，需要挂载内存：</p><pre class="highlight"><code class="bash">$ mkdir /mnt/huge$ mount -t hugetlbfs nodev /mnt/huge</code></pre><p>将以下命令添加到 <code>/etc/fstab</code> 可以永久保存:</p><pre class="highlight"><code class="">nodev /mnt/huge hugetlbfs defaults 0 0</code></pre><h3 id="加载内核模块"><a class="markdownIt-Anchor" href="#加载内核模块"></a> 加载内核模块</h3><h4 id="uio"><a class="markdownIt-Anchor" href="#uio"></a> UIO</h4><ul><li>Linux 内核所包含的标准 <em>uio_pci_generic</em> 模块可提供 UIO 能力<pre class="highlight"><code class="bash">$ sudo modprobe uio_pci_generic</code></pre></li><li>DPDK 提供了一个 <em>igb_uio</em> 模块，在 <code>$DPDK_TARGET/kmod</code> 目录<pre class="highlight"><code class="bash">$ sudo modprobe uio$ sudo insmod <span class="hljs-variable">$DPDK_TARGET</span>/kmod/igb_uio.ko</code></pre></li></ul><h4 id="vfio"><a class="markdownIt-Anchor" href="#vfio"></a> VFIO</h4><p>Linux 内核从 3.6.0 之后默认包含 <em>VFIO</em> 模块，因此也可使用该模块</p><pre class="highlight"><code class="bash">$ sudo modprobe vfio-pci</code></pre><h3 id="绑定端口"><a class="markdownIt-Anchor" href="#绑定端口"></a> 绑定端口</h3><p>DPDK 程序在运行前，需要将所要使用的端口绑定到 <em>uio_pci_generic</em>, <em>igb_uio</em> 或 <em>vfio-pci</em> 模块上</p><ol><li>停用网卡<pre class="highlight"><code class="bash">$ ifconfig eth0 down</code></pre></li><li><code>usertools/dpdk-devbind.py</code> 提供当前系统上网络接口的状态，绑定或解绑定来自不同内核模块的接口<pre class="highlight"><code class="bash">$ dpdk-devbind.py --status  <span class="hljs-comment"># 查看状态</span>$ dpdk-devbind.py --status-dev eth0 <span class="hljs-comment"># 查看接口状态</span>$ dpdk-devbind.py --<span class="hljs-built_in">bind</span>=igb_uio 03:00.0    <span class="hljs-comment"># 绑定接口到 igb_uio 驱动，可使用接口名称</span>$ dpdk-devbind.py -u 0000:03:00.0   <span class="hljs-comment"># 解绑</span></code></pre></li></ol><h2 id="运行实例"><a class="markdownIt-Anchor" href="#运行实例"></a> 运行实例</h2><h3 id="构建"><a class="markdownIt-Anchor" href="#构建"></a> 构建</h3><p>构建实例时，需要导入以下环境变量：</p><ul><li><code>RTE_SDK</code> - 指向 DPDK 安装目录</li><li><code>RTE_TARGET</code> - 指向 DPDK 目标环境目录</li></ul><pre class="highlight"><code class="bash">$ <span class="hljs-built_in">export</span> RTE_SDK=&lt;DPDK_DIR&gt;$ <span class="hljs-built_in">export</span> RTE_TARGET=&lt;RTE_TARGET&gt;$ make</code></pre><p>为保持项目文件夹纯净，也可将实例放在其他目录以保持 DPDK 目录结构不变<br />此处以 l2fwd 举例：</p><pre class="highlight"><code class="bash">$ cp ~/dpdk/examples/l2fwd ~/l2fwd-eg$ <span class="hljs-built_in">export</span> RTE_SDK=~/dpdk$ <span class="hljs-built_in">export</span> RTE_TARGET=x86_64-native-linuxapp-gcc$ <span class="hljs-built_in">cd</span> ~/l2fwd-eg$ make</code></pre><h3 id="启动环境-2"><a class="markdownIt-Anchor" href="#启动环境-2"></a> 启动环境</h3><ol><li><a href="#hugepages">hugepages</a>，若此前永久保存，可略过</li><li><a href="#%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97">加载内核模块</a>，因为 UIO 需要内核支持</li><li><a href="#%E7%BB%91%E5%AE%9A%E7%AB%AF%E5%8F%A3">绑定端口</a>，DPDK 作用是收发数据包，因此需要配置端口</li></ol><h3 id="eal"><a class="markdownIt-Anchor" href="#eal"></a> EAL</h3><blockquote><p>EAL，Environment Abstraction Layer，环境抽象层</p></blockquote><p>应用程序与 DPDK 目标环境的环境抽象库相关联，也就是说，每个实例运行的参数分为 EAL 参数和自身的参数。</p><p>示例：</p><pre class="highlight"><code class="bash">$ &lt;example&gt; -c &lt;coremask&gt; -l &lt;corelist&gt; -n 2 -- -i$ l2fwd -c 0x3 -l 2,3,4 -n 2 -- -i</code></pre><p>常用参数：</p><ul><li><code>-c</code>：核心数的十六进制掩码，如 11 对应 0x3<br />读取 <code>/proc/cpuinfo</code> 中的 <code>physical id</code> 可知 core 的信息</li><li><code>-l</code>：逻辑核心列表，第一个核用于管理命令行</li><li><code>-n</code>：内存通道数</li><li><code>--master-lcore</code>：主服务器的核心</li><li><code>-p</code>：端口十六进制掩码</li><li><code>--</code>：分割 EAL 与各实例的参数</li><li><code>-i</code>：某些实例如 <em>testpmd</em> 有可交互的参数</li></ul><p>至此，DPDK 的部署工作基本完成。文章并不详细，算不上教程，没有给出所以然，权当一个记录，若有需要，今后再做补充；如有问题，欢迎讨论。</p><p>工具包提供了不少脚本以供加快进度，同时 <code>/examples</code> 下包含了几十个实例，不得不说，<em>Intel©️DPDK</em> 项目很友好，后续将深入学习。</p>]]></content>
      
      
      <categories>
          
          <category> 系统开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DPDK </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PE 文件格式</title>
      <link href="/2018/12/PE-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
      <url>/2018/12/PE-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h2><p>PE 格式是由 <em>Unix</em> 中的 COFF 格式修改而来的，在 Windows 环境中，PE 格式也称为 <em>PE/COFF 格式</em></p><p>在 Win64 系统上运行的原生 64 位应用程序，其 PE 格式称为 <em>PE32+</em>，与 PE 不同之处基本只是在 PE 头 <em>IMAGE_NT_HEADERS</em></p><h3 id="常见格式"><a class="markdownIt-Anchor" href="#常见格式"></a> 常见格式</h3><ul><li>EXE</li><li>DLL（动态链接库）</li><li>SYS（驱动程序）</li><li>COM</li><li>OCX</li><li>EFI</li></ul><h3 id="文件结构概览"><a class="markdownIt-Anchor" href="#文件结构概览"></a> 文件结构概览</h3><pre class="highlight"><code class="">|——IMAGE_DOS_HEADER                     | +40h |——e_magic                 4D 5A |——xxx |——e_lfanew   xx xx xx xx|——DOS Stub|——IMAGE_NT_HEADERS                     | |——Signature               50 45 00 00 | +04h |——IMAGE_FILE_HEADER                   | +14h |——IMAGE_OPTIONAL_HEADER               | +224h/+240h  |——IMAGE_DATA_DIRECTORY               |  01h x 16|——IMAGE_SECTION_HEADER                 | +28h x (n + 1)|——SECTIONs</code></pre><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><ol><li><p>EP</p><blockquote><p>Entry Pointer，入口点</p></blockquote><p>EP是一个RVA，EP + Imagebase = 入口点的VA<br />通常情况下，EP指向的不是main函数</p></li><li><p>OEP</p><blockquote><p>Original Entery Pointer，原始入口点</p></blockquote></li><li><p>INT</p><blockquote><p>Import Name Table，导入名称表，一个结构体数组，详见 <strong>导入表</strong></p></blockquote></li><li><p>对齐<br />文件对齐的最小单位是磁盘扇区的单位，0x0200 字节<br />内存对齐的最小单位是 CPU 内存分页大小，Win32 0x1000 字节，即 4 KiB</p></li><li><p>节偏移<br />内存中数据节相对于装载基址的偏移量(<em>RVA</em>)和文件中数据节的偏移量(<em>FOA</em>)的差异称为节偏移</p></li></ol><h3 id="地址"><a class="markdownIt-Anchor" href="#地址"></a> 地址</h3><ol><li><p><em>ImageBase</em><br />基地址，磁盘中的文件加载到内存中时可以加载到任意位置，即程序的基址<br />建议装载地址，详见 <strong>重定位表</strong></p><ul><li>EXE 默认加载基址是 <code>0x00400000h</code></li><li>DLL 默认加载基址是 <code>0x10000000h</code></li></ul><blockquote><p>需要注意的是基地址不是程序的入口点</p></blockquote></li><li><p>VA</p><blockquote><p>虚拟地址，Virtual Address</p></blockquote><p>程序运行时被加载到 <strong>内存</strong> 中的地址</p></li><li><p>RVA</p><blockquote><p>相对虚拟地址，Relative Virtual Address</p></blockquote><p>是在内存中相对于 <strong>映射基地址</strong> (EXE 文件为<em>ImageBase</em>)的偏移量</p></li><li><p>FOA</p><blockquote><p>文件偏移地址，File Offset Address</p></blockquote><p>当PE文件储存在某个磁盘当中的时候，某个数据的位置相对于 <strong>文件头</strong> 的偏移量</p></li><li><p>地址转换</p><ol><li>VA = ImageBase + RVA</li><li>FOA = VA - ImageBase - 节偏移</li><li>FOA = RVA - 节偏移</li></ol></li></ol><h2 id="ms-dos-header"><a class="markdownIt-Anchor" href="#ms-dos-header"></a> MS-DOS Header</h2><p>PE 文件第一个字节起始于 MS-DOS 头部，该头部被定义为 <em>IMAGE_DOS_HEADER</em><br />DOS 头部为了兼容 DOS 系统而遗留的，最后一个字节给出了 PE 头的地址</p><h3 id="结构体-image_dos_header"><a class="markdownIt-Anchor" href="#结构体-image_dos_header"></a> 结构体 IMAGE_DOS_HEADER</h3><pre class="highlight"><code class="C">typrdef <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DOS_HEADER</span> {</span>    WORD   e_magic;          <span class="hljs-comment">// +0000h - EXE标志，"MZ"</span>    WORD   e_cblp;           <span class="hljs-comment">// +0002h - 最后（部分）页中的字节数</span>    WORD   e_cp;             <span class="hljs-comment">// +0004h - 文件中的全部和部分页数</span>    WORD   e_crlc;           <span class="hljs-comment">// +0006h - 重定位表中的指针数</span>    WORD   e_cparhdr;        <span class="hljs-comment">// +0008h - 头部尺寸，以段落为单位</span>    WORD   e_minalloc;       <span class="hljs-comment">// +000ah - 所需的最小附加段</span>    WORD   e_maxalloc;       <span class="hljs-comment">// +000ch - 所需的最大附加段</span>    WORD   e_ss;             <span class="hljs-comment">// +000eh - 初始的SS值（相对偏移量）</span>    WORD   e_sp;             <span class="hljs-comment">// +0010h - 初始的SP值</span>    WORD   e_csum;           <span class="hljs-comment">// +0012h - 补码校验值</span>    WORD   e_ip;             <span class="hljs-comment">// +0014h - 初始的IP值</span>    WORD   e_cs;             <span class="hljs-comment">// +0016h - 初始的CS值</span>    WORD   e_lfarlc;         <span class="hljs-comment">// +0018h - 重定位表的字节偏移量</span>    WORD   e_ovno;           <span class="hljs-comment">// +001ah - 覆盖号</span>    WORD   e_res[<span class="hljs-number">4</span>];         <span class="hljs-comment">// +001ch - 保留字00</span>    WORD   e_oemid;          <span class="hljs-comment">// +0024h - OEM标识符</span>    WORD   e_oeminfo;        <span class="hljs-comment">// +0026h - OEM信息</span>    WORD   e_res2[<span class="hljs-number">10</span>];       <span class="hljs-comment">// +0028h - 保留字</span>    LONG   e_lfanew;         <span class="hljs-comment">// +003ch - PE头相对于文件的偏移地址</span>  } IMAGE_DOS_HEADER, *IMAGE_DOS_HEADER;</code></pre><h3 id="字段解析"><a class="markdownIt-Anchor" href="#字段解析"></a> 字段解析</h3><ol><li><code>e_magic</code><ul><li>占用 <strong>2</strong> 字节</li><li>值：<strong><code>4D 5A</code></strong></li><li>ASCII：<strong><code>MZ</code></strong></li><li>DOS 头的标记位</li><li>即&quot;MZ&quot; Header，<em>Mark Zbikowski</em> 的姓名缩写，他是最初的 MS-DOS 设计者之一</li><li><em>Winnt.h</em> 宏定义如下<pre class="highlight"><code class="C"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> IMAGE_DOS_SIGNATURE 0x5A4D  <span class="hljs-comment">// MZ</span></span></code></pre></li></ul></li><li><code>e_lfanew</code><ul><li>占用 <strong>4</strong> 字节</li><li>这是一个 RVA，代表 PE 文件头到基址的偏移量，可用来找到 PE 文件头的位置</li></ul></li></ol><h3 id="dos-stub"><a class="markdownIt-Anchor" href="#dos-stub"></a> DOS Stub</h3><ul><li>当 Win32 程序在 DOS 下执行时会输出 <code>This program cannot be run in DOS mode</code></li><li>该部分可有可无，可填充其他内容，一般由编译器生成</li><li><code>e_lfanew</code> 到 <code>e_lfanew</code> 所指出的地址之间的内容</li></ul><h2 id="pe-header"><a class="markdownIt-Anchor" href="#pe-header"></a> PE Header</h2><ul><li>PE 头由 <em>IMAGE_NT_HEADERS</em> 结构体定义<ul><li><em>IMAGE_NT_HEADERS</em> 是一个宏定义，有 <strong>32位</strong> 和 <strong>64位</strong> 之别<pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><span class="hljs-keyword">typedef</span> IMAGE_NT_HEADER64   IMAGE_NT_HEADER;<span class="hljs-keyword">typedef</span> PIMAGE_NT_HEADER64  PIMAGE_NT_HEADER;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-keyword">typedef</span> IMAGE_NT_HEADER32   IMAGE_NT_HEADER;<span class="hljs-keyword">typedef</span> PIMAGE_NT_HEADER32  PIMAGE_NT_HEADER;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></li></ul></li><li>起始地址由 <code>IMAGE_DOS_HEADER.lfanew</code> 给出</li><li>真正用来装载 Windows 程序</li></ul><h3 id="结构体-image_nt_headers"><a class="markdownIt-Anchor" href="#结构体-image_nt_headers"></a> 结构体 IMAGE_NT_HEADERS</h3><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_NT_HEADERS</span> {</span>    DWORD Signature;                        <span class="hljs-comment">// +0000h - PE00</span>    IMAGE_FILE_HEADER FileHeader;           <span class="hljs-comment">// +0004h - PE 标准头</span>    IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="hljs-comment">// +0018h - PE 选项头</span> <span class="hljs-comment">// IMAGE_OPTIONAL_HEADER64 OptionalHeader;</span>}</code></pre><h3 id="signature"><a class="markdownIt-Anchor" href="#signature"></a> Signature</h3><ul><li>判断是否是 PE 文件</li><li>占用 <strong>4</strong> 字节</li><li>ASCII：<strong><code>PE00</code></strong></li><li>值：<strong><code>00 00 45 50</code></strong></li><li>宏定义如下<pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_NT_SIGNATURE 0x00004550   <span class="hljs-comment">// PE00</span></span></code></pre></li></ul><h3 id="fileheader"><a class="markdownIt-Anchor" href="#fileheader"></a> FileHeader</h3><ul><li>描述文件相关信息</li><li><strong>文件头</strong> 由 <code>IMAGE_DOS_HEADER.e_lfanew</code> 指定地址后的 20 个字节</li><li>结构体大小定义如下<pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_SIZEOF_FILE_HEADER    20</span></code></pre></li></ul><h4 id="结构体-image_file_header"><a class="markdownIt-Anchor" href="#结构体-image_file_header"></a> 结构体 IMAGE_FILE_HEADER</h4><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_FILE_HEADER</span> {</span>    WORD    Machine;              <span class="hljs-comment">// +0004h - 运行平台</span>    WORD    NumberOfSections;     <span class="hljs-comment">// +0006h - PE中节的数量</span>    DWORD   TimeDateStamp;        <span class="hljs-comment">// +0008h - 文件创建日期和时间</span>    DWORD   PointerToSymbolTable; <span class="hljs-comment">// +000ch - 指向符号表</span>    DWORD   NumberOfSymbols;      <span class="hljs-comment">// +0010h - 符号表中的符号数量</span>    WORD    SizeOfOptionalHeader; <span class="hljs-comment">// +0014h - 选项头结构的长度</span>    WORD    Characteristics;      <span class="hljs-comment">// +0016h - 文件属性</span>}</code></pre><h4 id="字段解析-2"><a class="markdownIt-Anchor" href="#字段解析-2"></a> 字段解析</h4><ol><li><code>Machine</code><ul><li><code>0x0000</code>：适用于任何类型处理器</li><li><code>0x01D3</code>：Matsushita AM33 处理器</li><li><code>0x8664</code>：x64 处理器</li><li><code>0x01C0</code>：ARM 小端处理器</li><li><code>0x0EBC</code>：EFI 字节码处理器</li><li><strong><code>0x014C</code>：Intel 32</strong></li><li><strong><code>0x0200</code>：Intel 64</strong></li><li><code>0x9041</code>：Mitsubishi M32R 小端处理器</li><li><code>0x0266</code>：MIPS16 处理器</li><li><code>0x366</code>：带 FPU 的 MIPS 处理器</li><li><code>0x466</code>：带 FPU 的 MIPS16 处理器</li><li><code>0x1F0</code>：PowerPC 小端处理器</li><li><code>0x1F1</code>：带符点运算支持的 PowerPC 处理器</li><li><code>0x166</code>：MIPS 小端处理器</li><li><code>0x1A2</code>：Hitachi SH3 处理器</li><li><code>0x1A3</code>：Hitachi SH3 DSP 处理器</li><li><code>0x1A6</code>：Hitachi SH4 处理器</li><li><code>0x1A6</code>：Hitachi SH5 处理器</li><li><code>0x1C2</code>：Thumb 处理器</li><li><code>0x169</code>：MIPS 小端 WCE v2 处理器</li></ul></li><li><code>TimeDateStamp</code>：自格林尼治 <em>1970.1.1</em> 以来时间</li><li><code>SizeOfOptionalHeader</code>：指定 <strong>IMAGE_OPTIONAL_HEADER</strong> 结构体大小，也是 <strong>32位</strong> 和 <strong>64位</strong> 的区别</li><li><code>Characteristics</code>：指定该文件类型<ul><li>0表明此文件不包含基址重定位信息，因此必须被加载到其首选基地址上。基地址不可用则报错</li><li>1表明此镜像文件是合法的</li><li>2保留，必须为 0</li><li>3 保留，必须为 0</li><li>4 保留，必须为 0</li><li>5应用程序可以处理大于 2GB 的地址</li><li>6保留，必须为 0</li><li>7保留，必须为 0</li><li>8机器类型基于 32 位体系结构</li><li>9调试信息已经从此镜像文件中移除</li><li>10 如果此镜像文件在可移动介质上，完全加载它并把它复制到交换文件中。几乎不用</li><li>11 如果此镜像文件在网络介质上，完全加载它并把它复制到交换文件中。几乎不用</li><li>12 此镜像文件是系统文件，而不是用户程序</li><li>13 此镜像文件是 DLL</li><li>14 此文件只能运行于单处理器机器上</li><li>15 保留，必须为 0</li></ul></li></ol><h3 id="optionalheader"><a class="markdownIt-Anchor" href="#optionalheader"></a> OptionalHeader</h3><ul><li>选项头，通常称为 “可选头”</li><li>管理 PE 文件装载时所需的文件</li><li>宏定义如下<pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span><span class="hljs-keyword">typedef</span> IMAGE_OPTIONAL_HEADER64             IMAGE_OPTIONAL_HEADER;<span class="hljs-keyword">typedef</span> PIMAGE_OPTIONAL_HEADER64            PIMAGE_OPTIONAL_HEADER;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_SIZEOF_NT_OPTIONAL_HEADER     IMAGE_SIZEOF_NT_OPTIONAL64_HEADER</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR_MAGIC         MAGE_NT_OPTIONAL_HDR64_MAGIC</span><span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-keyword">typedef</span> IMAGE_OPTIONAL_HEADER32             IMAGE_OPTIONAL_HEADER;<span class="hljs-keyword">typedef</span> PIMAGE_OPTIONAL_HEADER32            PIMAGE_OPTIONAL_HEADER;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_SIZEOF_NT_OPTIONAL_HEADER     IMAGE_SIZEOF_NT_OPTIONAL32_HEADER</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR_MAGIC         IMAGE_NT_OPTIONAL_HDR32_MAGIC</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre></li><li>大小由 <code>IMAGE_FILE_HEADER.SizeOfOptionalHeader</code> 给出<ul><li>宏定义如下<pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_SIZEOF_NT_OPTIONAL32_HEADER 224</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_SIZEOF_NT_OPTIONAL64_HEADER 240</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR32_MAGIC   0x10b</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_NT_OPTIONAL_HDR64_MAGIC   0x20b</span></code></pre></li><li>32位：<code>0x00E0</code> 字节，即 224 字节</li><li>64位：<code>0x00F0</code> 字节，即 240 字节</li><li>区别：整体增加 16 字节<ol><li><code>BaseOfData</code> 64 位版本不存在</li><li><code>ImageBase</code>、<code>SizeOfStackReserve</code>、<code>SizeOfStackCommit</code>、<code>SizeOfHeapReserve</code>、<code>SizeOfHeapCommit</code> 字段由 4 字节变为 8 字节</li></ol></li></ul></li><li>通常结束于 <code>.text</code> 节之前</li></ul><h4 id="结构体-image_optional_header"><a class="markdownIt-Anchor" href="#结构体-image_optional_header"></a> 结构体 IMAGE_OPTIONAL_HEADER</h4><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_OPTIONAL_HEADER</span> {</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// Standard fields.</span>    <span class="hljs-comment">//</span>    WORD    Magic;                 <span class="hljs-comment">// +0018h - 指定文件标识</span>    BYTE    MajorLinkerVersion;    <span class="hljs-comment">// +001ah - 链接器主版本号</span>    BYTE    MinorLinkerVersion;    <span class="hljs-comment">// +001bh - 连接器次版本号</span>    DWORD   SizeOfCode;            <span class="hljs-comment">// +001ch - 所有含代码的节的总大小</span>    DWORD   SizeOfInitializedData;   <span class="hljs-comment">// +0020h - 所有含已初始化数据的节的总大小</span>    DWORD   SizeOfUninitializedData; <span class="hljs-comment">// +0024h - 所有含未初始化数据的节的大小</span>    DWORD   AddressOfEntryPoint;     <span class="hljs-comment">// +0028h - 程序执行入口RVA</span>    DWORD   BaseOfCode;            <span class="hljs-comment">// +002ch - 代码节的起始RVA</span>    DWORD   BaseOfData;            <span class="hljs-comment">// +0030h - 数据节的起始RVA</span><span class="hljs-comment">// 该字段 64 位版本将不存在</span>    <span class="hljs-comment">//</span>    <span class="hljs-comment">// NT additional fields.</span>    <span class="hljs-comment">//</span>    DWORD   ImageBase;             <span class="hljs-comment">// +0034h - 程序的建议装载地址</span><span class="hljs-comment">//ULONGLONG ImageBase;</span>    DWORD   SectionAlignment;      <span class="hljs-comment">// +0038h - 内存中节的对齐粒度</span>    DWORD   FileAlignment;         <span class="hljs-comment">// +003ch - 文件中节的对齐粒度</span>    WORD    MajorOperatingSystemVersion; <span class="hljs-comment">// +0040h - 操作系统主版本号</span>    WORD    MinorOperatingSystemVersion; <span class="hljs-comment">// +0042h - 操作系统次版本号</span>    WORD    MajorImageVersion;     <span class="hljs-comment">// +0044h - 该PE主版本号</span>    WORD    MinorImageVersion;     <span class="hljs-comment">// +0046h - 该PE次版本号</span>    WORD    MajorSubsystemVersion; <span class="hljs-comment">// +0048h - 子系统的主版本号</span>    WORD    MinorSubsystemVersion; <span class="hljs-comment">// +004ah - 子系统的次版本号</span>    DWORD   Win32VersionValue;     <span class="hljs-comment">// +004ch - 保留</span>    DWORD   SizeOfImage;           <span class="hljs-comment">// +0050h - 内存中的整个PE映像大小</span>    DWORD   SizeOfHeaders;         <span class="hljs-comment">// +0054h - 所有头+节表的大小</span>    DWORD   CheckSum;              <span class="hljs-comment">// +0058h - 校验和</span>    WORD    Subsystem;             <span class="hljs-comment">// +005ch - 文件的子系统</span>    WORD    DllCharacteristics;    <span class="hljs-comment">// +005eh - DLL文件特性</span>    DWORD   SizeOfStackReserve;    <span class="hljs-comment">// +0060h - 初始化时的栈大小</span>    DWORD   SizeOfStackCommit;     <span class="hljs-comment">// +0064h - 初始化时实际提交的栈大小</span>    DWORD   SizeOfHeapReserve;     <span class="hljs-comment">// +0068h - 初始化时保留的堆大小</span>    DWORD   SizeOfHeapCommit;      <span class="hljs-comment">// +006ch - 初始化时实际提交的堆大小</span><span class="hljs-comment">//ULONGLONG SizeOfStackReserve;</span><span class="hljs-comment">//ULONGLONG SizeOfStackCommit;</span><span class="hljs-comment">//ULONGLONG SizeOfHeapReserve;</span><span class="hljs-comment">//ULONGLONG SizeOfHeapCommit;</span>    DWORD   LoaderFlags;           <span class="hljs-comment">// +0070h - 与调试有关</span>    DWORD   NumberOfRvaAndSizes;   <span class="hljs-comment">// +0074h - 下面的数据目录结构数量</span>    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];    <span class="hljs-comment">// +0078h - 数据目录</span>} IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;</code></pre><h5 id="结构体-image_data_directory"><a class="markdownIt-Anchor" href="#结构体-image_data_directory"></a> 结构体 IMAGE_DATA_DIRECTORY</h5><p><em>IMAGE_DATA_DIRECTORY</em> 定义如下</p><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_DATA_DIRECTORY</span> {</span>DWORD   VirtualAddress; <span class="hljs-comment">// +0000h - 数据的起始RVA</span>DWORD   Size;           <span class="hljs-comment">// +0004h - 数据块的长度，非准确值</span>} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</code></pre><h4 id="字段解析-3"><a class="markdownIt-Anchor" href="#字段解析-3"></a> 字段解析</h4><ol><li><code>Magic</code>：决定 <em>IMAGE_OPTIONAL_HEADER</em> 版本<table><thead><tr><th>Magic</th><th>版本</th></tr></thead><tbody><tr><td>0x010B</td><td>PE32</td></tr><tr><td>0x020B</td><td>PE32+</td></tr></tbody></table></li><li><code>AddressOfEntryPoint</code>：程序执行的入口，该地址是一个 RVA，指向执行的第一条代码</li><li><code>ImageBase</code>：默认加载基址</li><li><code>BaseOfCode</code>：代码节的起始位置</li><li><code>BaseOfData</code>：只存在于 <strong>32位</strong> 版本，很多情况下可以为 0</li><li><code>SectionAlignment</code>：内存中的块对齐值，一般为 <code>0x1000</code><em>(4096)</em> 字节，即 <code>4KiB</code></li><li><code>FileAlignment</code>：文件中的块对齐值，一般为 <code>0x200</code><em>(512)</em> 字节或 <code>0x1000</code><em>(4096)</em> 字节</li><li><code>SizeOfHeaders</code>：整个头部即DOS头、PE头以及节表总大小，该值按照 <code>FileAlignment</code> 对齐</li><li><code>Subsystem</code><ul><li>0    未知子系统</li><li><strong>1设备驱动程序和Native Windows进程</strong></li><li><strong>2图形用户界面子系统，即一般程序</strong></li><li><strong>3控制台子系统</strong></li><li>7     Posix 字符模式子系统</li><li>9    Windows CE</li><li>10    可扩展固件接口（EFI）应用程序</li><li>11    带引导服务的 EFI 驱动程序</li><li>12    带运行时服务的 EFI 驱动程序</li><li>13    EFI ROM 镜像</li><li>14    XBOX 子系统</li></ul></li><li><code>DllCharacteristics</code><ul><li>1保留，必须为 0</li><li>2保留，必须为 0</li><li>3保留，必须为 0</li><li>4保留，必须为 0</li><li>5官方文档缺失</li><li>6官方文档缺失</li><li>7DLL 可以在加载时被重定位</li><li>8强制进行代码完整性校验</li><li>9镜像兼容于 NX</li><li>10 可以隔离，但并不隔离此镜像</li><li>11 不使用结构化异常（SE）处理</li><li>12 不绑定镜像</li><li>13 保留，必须为 0</li><li>14 WDM 驱动程序</li><li>15 官方文档缺失</li><li>16 可以用于终端服务器</li></ul></li><li><code>NumberOfRvaAndSizes</code>：数据目录项个数，宏定义如下<pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16</span></code></pre></li><li><code>DataDirectory</code><ul><li>该数组定义了 PE 文件中出现的所有不同类型的数据目录信息</li><li>数据目录中定义的数据类型有 16 种，下标从 0 开始</li><li>下标说明<ul><li>0 <strong>导出表</strong> 地址下标</li><li>1 <strong>导入表</strong> 地址下标</li><li>2 <strong>资源表</strong> 地址下标</li><li>3 异常表地址下标</li><li>4 属性证书数据地址下标</li><li>5 基地址 <strong>重定位</strong> 表地址下标</li><li>6 调试信息地址索引</li><li>7 预留为 0</li><li>8 指向全局指针寄存器的值</li><li>9 线程局部存储索引</li><li>10 加载配置表索引</li><li>11 绑定导入表索引</li><li>12 <strong>导入函数</strong> 地址表索引</li><li>13 延迟导入表索引</li><li>14 CLR 运行时头部数据索引</li><li>15 系统保留</li></ul></li></ul></li></ol><h2 id="directory-section"><a class="markdownIt-Anchor" href="#directory-section"></a> Directory Section</h2><ul><li>在 <em>IMAGE_OPTIONAL_HEADER</em> 之后，由多个节表项(<em>IMAGE_SECTION_HEADER</em>)组成</li><li>每个节表项记录了 PE 中与某个特定的节有关的信息，如节的属性、节的大小、在文件和内存中的起始位置等</li><li>节表中节的数量由 <em>IMAGE_FILE_HEADER.NumberOfSection</em> 字段来定义</li><li>结构体大小定义如下<pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_SIZEOF_SECTION_HEADER    40</span></code></pre></li></ul><h3 id="常见命名"><a class="markdownIt-Anchor" href="#常见命名"></a> 常见命名</h3><table><thead><tr><th>节区名称</th><th>描述</th></tr></thead><tbody><tr><td><code>.text</code></td><td>包含 CPU 指令，唯一包含代码的节</td></tr><tr><td><code>.data</code></td><td>可 <strong>读写</strong> 的数据，存放全局变量或静态变量</td></tr><tr><td><code>.rdata</code></td><td><strong>全局</strong> 可访问的 <strong>只读</strong> 数据</td></tr><tr><td><code>.rodata</code></td><td></td></tr><tr><td><code>.idata</code></td><td>显示和存储导入函数，如果不存在则存放于 <code>.rdata</code></td></tr><tr><td><code>.edata</code></td><td>显示和存储导出数据，如果不存在则存放于 <code>.rdata</code></td></tr><tr><td><code>.pdata</code></td><td>只存在于 64位 可执行文件，处理异常信息</td></tr><tr><td><code>.rsrc</code></td><td>存放程序用到的所有资源，如图表，菜单等</td></tr><tr><td><code>.reloc</code></td><td>包含重定位信息</td></tr><tr><td><code>.bss</code></td><td>未初始化数据区</td></tr><tr><td><code>.crt</code></td><td>用于支持C++运行时库所添加的数据</td></tr><tr><td><code>.tls</code></td><td>存储线程局部变量</td></tr><tr><td><code>.sdata</code></td><td>包含相对于可被全局指针定位的可读写数据</td></tr><tr><td><code>.srdata</code></td><td>包含相对于可被全局指针定位的只读数据</td></tr><tr><td><code>.debug$S</code></td><td>包含OBJ文件中的Codeview格式符号</td></tr><tr><td><code>.debug$T</code></td><td>包含OBJ文件中的Codeview格式类型的符号</td></tr><tr><td><code>.debug$P</code></td><td>包含使用预编译头时的一些信息</td></tr><tr><td><code>.drectve</code></td><td>包含编译时的一些链接命令</td></tr><tr><td><code>.comment</code></td><td></td></tr><tr><td><code>.didat</code></td><td>包含延迟装入的数据</td></tr></tbody></table><h3 id="结构体-image_section_header"><a class="markdownIt-Anchor" href="#结构体-image_section_header"></a> 结构体 IMAGE_SECTION_HEADER</h3><pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_SIZEOF_SHORT_NAME    8</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_SECTION_HEADER</span> {</span>    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]; <span class="hljs-comment">// +0000h - 节名</span>    <span class="hljs-keyword">union</span> {            DWORD   PhysicalAddress;            DWORD   VirtualSize;    } Misc;                        <span class="hljs-comment">// +0008h - 节区的尺寸</span>    DWORD   VirtualAddress;        <span class="hljs-comment">// +000ch - 节区的RVA地址</span>    DWORD   SizeOfRawData;         <span class="hljs-comment">// +0010h - 在文件中对齐后的大小</span>    DWORD   PointerToRawData;      <span class="hljs-comment">// +0014h - 在文件中的偏移</span>    DWORD   PointerToRelocations;  <span class="hljs-comment">// +0018h - 在OBJ文件中使用</span>    DWORD   PointerToLinenumbers;  <span class="hljs-comment">// +001ch - 行号表的位置（调试用）</span>    WORD    NumberOfRelocations;   <span class="hljs-comment">// +0020h - 在OBJ文件中使用</span>    WORD    NumberOfLinenumbers;   <span class="hljs-comment">// +0022h - 行号表中行号的数量</span>    DWORD   Characteristics;       <span class="hljs-comment">// +0024h - 节的属性</span>} IMAGE_SECTION_HEADER，*PIMAGE_SECTION_HEADER;</code></pre><h3 id="字段解析-4"><a class="markdownIt-Anchor" href="#字段解析-4"></a> 字段解析</h3><ol><li><code>Name</code>：节表项名称，长度为 8 的 ASCII 码字符，常用 <code>.</code> 起始命名</li><li><code>Characteristics</code><ul><li>1、2、3、4、5 已经废除</li><li><strong>6 此节包含可执行代码 <code>.text</code></strong></li><li><strong>7 此节包含已初始化的数据 <code>.data</code></strong></li><li><strong>8 此节包含未初始化的数据 <code>.bss</code></strong></li><li>9、10、11、12、13、14、15 已经废除</li><li>16 此节包含通过全局指针（GP）来引用的数据</li><li>17、18、19、20、21、22、23、24 已经废除</li><li>25 此节包含扩展的重定位信</li><li>26 此节可以在需要时被丢弃</li><li>27 此节不能被缓存</li><li>28 此节不能被交换到页面文件中</li><li>29 此节可以在内存中共享</li><li><strong>30 此节可以作为代码执行</strong></li><li><strong>31 此节可读</strong></li><li><strong>32 此节可写</strong></li></ul></li></ol><h2 id="数据区"><a class="markdownIt-Anchor" href="#数据区"></a> 数据区</h2><p>有一些 PE 文件格式相关的结构体不在 PE 头部，而是分散在各个数据节中，位置由 <code>IMAGE_OPTIONAL_HEADER.DataDirtory</code> 数组给出<br />保存了导出表、导入表、重定位表等结构</p><h3 id="导出表"><a class="markdownIt-Anchor" href="#导出表"></a> 导出表</h3><ul><li>数据目录第 <strong>一</strong> 项</li><li>导出表即导出函数表，调用的 API 函数是由 DLL 文件导出的函数</li><li>通常导出表只存在于 DLL 文件</li></ul><h4 id="导出函数"><a class="markdownIt-Anchor" href="#导出函数"></a> 导出函数</h4><h5 id="导出函数的定义"><a class="markdownIt-Anchor" href="#导出函数的定义"></a> 导出函数的定义</h5><ol><li>直接在函数定义时导出</li><li>通过定义 <code>.def</code> 文件导出</li></ol><h5 id="导出函数的调用"><a class="markdownIt-Anchor" href="#导出函数的调用"></a> 导出函数的调用</h5><ol><li>隐式调用，程序编译时生成导入表</li><li>显示调用，通过 <em>LoadLibrary</em> 函数和 <em>GetProcAddress</em> 函数调用</li></ol><h4 id="结构体-image_export_directory"><a class="markdownIt-Anchor" href="#结构体-image_export_directory"></a> 结构体 IMAGE_EXPORT_DIRECTORY</h4><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_EXPORT_DIRECTORY</span> {</span>    DWORD   Characteristics;       <span class="hljs-comment">// 保留值，必须0</span>    DWORD   TimeDateStamp;         <span class="hljs-comment">// 时间戳</span>    WORD    MajorVersion;          <span class="hljs-comment">// 主版本号，默认0</span>    WORD    MinorVersion;          <span class="hljs-comment">// 次版本号，默认0</span>    DWORD   Name;                  <span class="hljs-comment">// PE文件的名称</span>    DWORD   Base;                  <span class="hljs-comment">// 序号基数</span>    DWORD   NumberOfFunctions;     <span class="hljs-comment">// 导出函数的数量</span>    DWORD   NumberOfNames;         <span class="hljs-comment">// 以函数名称导出的函数的数量</span>    DWORD   AddressOfFunctions;    <span class="hljs-comment">// 导出函数地址表的RVA</span>    DWORD   AddressOfNames;        <span class="hljs-comment">// 导出名称指针表的RVA</span>    DWORD   AddressOfNameOrdinals; <span class="hljs-comment">// 序号表的RVA</span>} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</code></pre><h4 id="字段解析-5"><a class="markdownIt-Anchor" href="#字段解析-5"></a> 字段解析</h4><ol><li><code>TimeDateStamp</code>：绑定导入表的时间戳会和 DLL 的时间戳对比，不相同则不生效</li><li><code>Name</code>：指向该文件名 ASCII 码字符串的 RVA</li><li><code>Base</code>：映像中导出符号的起始序数值，指定导出地址表的起始序数值，通常为 1</li><li><code>AddressOfNames</code>：保存导出名称指针表的 RVA，该表数量是 <code>NumberOfNames</code> 的值</li><li><code>AddressOfNameOrdinals</code>：导出序数表的 RVA，该表数量是 <code>NumberOfNames</code> 的值。此处的值是索引值，加上 <code>Base</code> 才是真正的序号</li></ol><h3 id="导入表"><a class="markdownIt-Anchor" href="#导入表"></a> 导入表</h3><ul><li>数据目录第 <strong>二</strong> 项</li><li>在 PE 文件运行时，需要别的 PE 文件给予的支持。因此导入表存储的是从其他文件导入过来的函数名，序号。在加载到内存之后，会存储这些函数的地址</li><li>由于一个 PE 文件可能会需要多个 PE 文件的支持，所以导入表结构一般有多个，即导入表是一个 <strong>结构体数组</strong> ，以一个全零元素为结尾，每一个数组的元素，代表一个 PE 文件的导入信息</li></ul><h4 id="绑定导入表"><a class="markdownIt-Anchor" href="#绑定导入表"></a> 绑定导入表</h4><ul><li>使用绑定导入表中的地址，需要有两个前提<ol><li>装载地址与 <code>IMAGE_OPTIONAL_HEADER.ImageBase</code> 相同</li><li>DLL 提供的函数地址没有变化</li></ol></li><li>结构体定义<pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_BOUND_IMPORT_DESCRIPTOR</span> {</span>    WORD    TimeDateStamp;    WORD    OffsetMosuleName;    WORD    NumberOfModuleForwarderRefs;} IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR;</code></pre></li><li>字段解析<ol><li><code>OffsetMosuleName</code>：绑定模块的名称，该值是一个以第一个 <em>IMAGE_BOUND_IMPORT_DESCRIPTOR</em> 为起始地址的偏移</li><li><code>NumberOfModuleForwarderRefs</code>：</li></ol></li><li>PE 文件装载时，Windows 需要根据导入表的模块名称和函数名称装载相应模块，得到导入函数的地址并填充导入地址表，绑定地址表则直接将导入函数写入 PE 文件</li></ul><h4 id="结构体-image_import_descriptor"><a class="markdownIt-Anchor" href="#结构体-image_import_descriptor"></a> 结构体 IMAGE_IMPORT_DESCRIPTOR</h4><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_DESCRIPTOR</span> {</span>    <span class="hljs-keyword">union</span> {        DWORD   Characteristics;        DWORD   OriginalFirstThunk; <span class="hljs-comment">// 指向一个 INT 的相对虚拟地址 RVA</span>    } DUMMYUNIONNAME;    DWORD   TimeDateStamp;          <span class="hljs-comment">// 时间标志</span>    DWORD   ForwarderChain;         <span class="hljs-comment">// 转发机制用到</span>    DWORD   Name;                   <span class="hljs-comment">// 导入的PE文件的名字的相对虚拟地址RVA</span>    DWORD   FirstThunk;             <span class="hljs-comment">// IAT，指向一个结构体数组 RVA</span>} IMAGE_IMPORT_DESCRIPTOR， *PIMAGE_IMPORT_DESCRIPTOR;</code></pre><h4 id="字段解析-6"><a class="markdownIt-Anchor" href="#字段解析-6"></a> 字段解析</h4><ol><li><code>OriginalFirstThunk</code>：保存了指向导入函数名称（序号）的 RVA 表，该表是一个 <code>IMAGE_THUNK_DATA</code> 结构体，定义如下<pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_THUNK_DATA32</span> {</span>    <span class="hljs-keyword">union</span> {        DWORD ForwarderString;        DWORD Function;       <span class="hljs-comment">//导入函数的地址</span>        DWORD Ordinal;        DWORD AddressOfData;    } u1;  } IMAGE_THUNK_DATA32;</code></pre><ul><li>该结构体分 <strong>32位</strong> 和 <strong>64位</strong> 版本</li><li>union 四个字段占用相同空间<ol><li><code>Ordinal</code>：导入函数的序号，<em>IMAGE_THUNK_DATA</em> 最高位为 1 时有效</li><li><code>AddressOfData</code>：指向 <em>IMAGE_IMPORT_BY_NAME</em> 结构体的 RVA，当 <em>IMAGE_THUNK_DATA</em> 最高位不为 1 时有效<blockquote><p>IMAGE_IMPORT_BY_NAME 结构体定义如下</p></blockquote><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_IMPORT_BY_NAME</span> {</span>    WORD    Hint;    CHAR   Name[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 表示导入函数名称，ASCII 码，以 NULL 结尾，长度 1 字节</span>} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</code></pre><blockquote><p><em>IMAGE_IMPORT_BY_NAME</em> 结构体可以了解导入函数是通过 <strong>序号</strong> 还是 <strong>名称</strong> 导入；</p><ul><li>序号导入，则序号可以在 <em>IMAGE_THUNK_DATA</em> 中获得</li><li>名称导入，则借助 <em>IMAGE_IMPORT_BY_NAME</em> 得到导入函数名称</li></ul></blockquote></li></ol></li></ul></li><li><code>FirstThunk</code>：装载内存前，保存了指向导入地址表的 RVA 表，与 <code>OriginalFirstThunk</code> 相同，装载内存后则写入 <strong>导入函数的实际地址</strong></li></ol><h3 id="重定位表"><a class="markdownIt-Anchor" href="#重定位表"></a> 重定位表</h3><p>建议装载地址：<code>IMAGE_OPTIONAL_HEADER.ImageBase</code> 字段是建议装载地址</p><ul><li>数据目录第 <strong>六</strong> 项</li><li>通过第五项进行定位，下标从 0 开始，索引定位如下<pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC 5 <span class="hljs-comment">// Base Relocation Table</span></span></code></pre></li><li>重定位表由多个 <em>IMAGE_BASE_RELOCATION</em> 组合而成，且以一个全 0 的结构体结束</li><li>重定位地址修正：<strong>实际装载地址</strong> 减去 <strong>建议装载地址</strong>，用得出的 <strong>差值</strong> 加上用建议装载地址得出的装载地址</li></ul><h4 id="结构体-image_base_relocation"><a class="markdownIt-Anchor" href="#结构体-image_base_relocation"></a> 结构体 IMAGE_BASE_RELOCATION</h4><pre class="highlight"><code class="C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IMAGE_BASE_RELOCATION</span> {</span>    DWORD   VirtualAddress; <span class="hljs-comment">// 重定位数据的 RVA</span>    DWORD   SizeOfBlock;    <span class="hljs-comment">// 结构体的大小</span>    WORD    TypeOffset[<span class="hljs-number">1</span>];  <span class="hljs-comment">// 偏移</span>} IMAGE_BASE_RELOCATION;</code></pre><h4 id="字段解析-7"><a class="markdownIt-Anchor" href="#字段解析-7"></a> 字段解析</h4><ol><li><code>SizeOfBlock</code>：当前区段重定位结构的大小，包括重定位数据，<em>IMAGE_BASE_RELOCATION</em> 结构体大小是 8 字节，即该值 <code>8 BYTE + n * WORD</code></li><li><code>TypeOffset</code>：高 4 位表示类型，低 12 位表示区段内需要重定位的 RVA 值<ul><li><code>TypeOffset</code> 类型取值定义如下<pre class="highlight"><code class="C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_REL_BASED_ABSOLUTE        0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_REL_BASED_HIGH            1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_REL_BASED_LOW             2</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_REL_BASED_HIGHLOW         3</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_REL_BASED_HIGHADJ         4</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_REL_BASED_MIPS_JMPADDR    5</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_REL_BASED_MIPS_JMPADDR    9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_REL_BASED_IA64_IMM64      9</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> IMAGE_REL_BASED_DIR64           10</span></code></pre></li><li>Win32 下，所有重定位类型都是 <em>IMAGE_REL_BASED_HIGHLOW</em></li><li><code>TypeOffset</code> 的数量：整个区段重定位结构的大小(<code>SizeOfBlock</code>)减去 8 字节，再除以 2 (<code>BYTE</code>)</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 参考 </tag>
            
            <tag> PE </tag>
            
            <tag> 文件格式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 部署</title>
      <link href="/2018/11/SSH-%E9%83%A8%E7%BD%B2/"/>
      <url>/2018/11/SSH-%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="ssh-概述"><a class="markdownIt-Anchor" href="#ssh-概述"></a> SSH 概述</h2><p>SSH，<a href="https://en.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener" title="Wiki">Secure Shell</a>，是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。该协议由 <em>IETF</em> 的网络工作小组（Network Working Group）制定。</p><p>SSH 是 Telnet 和非安全 shell 的替代品。Telnet 和 rsh、rexec 等协议采用明文传输，使用不可靠的密码，容易遭到监听、嗅探和中间人攻击。SSH 旨在保证非安全网络环境（例如互联网）中信息加密完整可靠。</p><p>众所周知，SSH 最常见的用途就是远程登录系统。</p><h2 id="openssh"><a class="markdownIt-Anchor" href="#openssh"></a> OpenSSH</h2><blockquote><p>OpenSSH（<a href="https://en.wikipedia.org/wiki/OpenSSH" target="_blank" rel="noopener" title="Wiki">OpenBSD Secure Shell</a>）是 OpenBSD 的子项目。它是取代由 SSH Communications Security 所提供的商用版本的开放源代码方案。</p></blockquote><p><a href="https://www.openssh.com" target="_blank" rel="noopener" title="主页">OpenSSH</a> 是 SSH 的一个开源实现，提供了服务端后台程序和客户端工具。</p><p>该项目主要由以下部分组成：</p><ul><li>远程操作工具：<ul><li>ssh</li><li>scp</li><li>sftp</li></ul></li><li>秘钥管理工具：<ul><li>ssh-add</li><li>ssh-keysign</li><li>ssh-keyscan</li><li>ssh-keygen</li></ul></li><li>服务器端程序：<ul><li>sshd</li><li>sftp-server</li><li>ssh-agent</li></ul></li></ul><p>其中比较常见的，ssh 是远程登陆的客户端，macOS 和大多数 Linux 发行版默认集成，Windows 从 Win10 1809 开始集成（以前版本则需要一些管理工具，如 Putty、Xshell、MobaXterm 等） ，sshd 是服务器端的守护进程，ssh-keygen 用于生成秘钥。</p><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><p>在服务器部署 OpenSSH 守护进程。</p><pre class="highlight"><code class="bash">$ apt install openssh-server     <span class="hljs-comment"># Ubuntu</span>$ yum install openssh-server     <span class="hljs-comment"># CentOS</span></code></pre><p>安装完毕可以在本机测试是否连通：</p><pre class="highlight"><code class="bash">$ ssh localhost</code></pre><h3 id="启动"><a class="markdownIt-Anchor" href="#启动"></a> 启动</h3><pre class="highlight"><code class="bash">$ service sshd start      <span class="hljs-comment"># Ubuntu、CentOS</span>$ /etc/init.d/ssh start   <span class="hljs-comment"># Debian</span></code></pre><h3 id="重启"><a class="markdownIt-Anchor" href="#重启"></a> 重启</h3><pre class="highlight"><code class="bash">$ service ssh restart     <span class="hljs-comment"># Ubuntu、CentOS</span>$ /etc/init.d/ssh restart <span class="hljs-comment"># Debian</span></code></pre><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><p>服务器配置文件路径：<code>/etc/ssh/sshd_config</code>。</p><p>部分说明如下：</p><pre class="highlight"><code class=""># StrictHostKeyChecking ask# IdentityFile ~/.ssh/id_rsa# IdentityFile ~/.ssh/id_dsa# IdentityFile ~/.ssh/id_ecdsa# IdentityFile ~/.ssh/id_ed25519# Port 22# Protocol 2# ListenAddress 0.0.0.0   绑定的 IP 地址# ServerKeyBits 1024      服务器秘钥位数# PermittedRootLogin yes  允许 root 登录# StrictModes yes         接受登录请求之前检查用户主目录# Tunnel no# TunnelDevice any:any# PrintMod yes  登录时显示 /etc/motd 信息# RSAAuthentication yes 允许 RSA 验证# PermitEmptyPasswords no# AllowUsers    允许连接的用户# AllowGroups   允许连接的群组# DenyUsers     拒绝连接的用户# Denygroups    拒绝连接的群组# PermitLocalCommand no# VisualHostKey no# RekeyLimit 1G 1h</code></pre><h2 id="第一次登录"><a class="markdownIt-Anchor" href="#第一次登录"></a> 第一次登录</h2><p>使用口令登录：</p><pre class="highlight"><code class="bash">$ ssh &lt;user&gt;@&lt;host&gt; -p [port]</code></pre><p>第一次登录，需要验证公钥指纹以权衡风险，会遇到如下提示：</p><pre class="highlight"><code class="">The authenticity of host 'host (12.18.429.97)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:33:16:58:4d.Are you sure you want to continue connecting (yes/no)?</code></pre><p>确认后输入 <code>yes</code> 即可登录服务器账户。</p><h3 id="公钥文件"><a class="markdownIt-Anchor" href="#公钥文件"></a> 公钥文件</h3><p>确认提示后会将所登录的主机写入一个文件，记录可信赖的 <strong>远程主机</strong> 的公钥，该文件路径如下：</p><ul><li>当前用户：<code>$HOME/.ssh/known_hosts</code></li><li>系统：<code>/etc/ssh/ssh_known_hosts</code></li></ul><p>实际上 <code>ssh</code> 文件夹下，有以下文件：</p><pre class="highlight"><code class="">id_rsaid_rsa.pubknown_hosts</code></pre><p><code>id_rsa</code> 和 <code>id_rsa.pub</code> 分别为用户主机的私钥和公钥。</p><h3 id="公钥登陆"><a class="markdownIt-Anchor" href="#公钥登陆"></a> 公钥登陆</h3><p>用户将自己的公钥储存在远程主机上，登录的时候，远程主机向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密</p><ol><li>生成用户公钥 <code>ssh-keygen</code></li><li>运行结束以后，<code>$HOME/.ssh/</code> 目录下会生成两个文件 <code>id_rsa.pub</code> 和 <code>id_rsa</code></li><li>前者是公钥，后者是私钥</li><li>用 <code>ssh-copy-id</code> 将公钥传送到远程主机上</li><li>检查远程主机的 <code>/etc/ssh/sshd_config</code><pre class="highlight"><code class="">RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys</code></pre></li></ol><h2 id="登录选项"><a class="markdownIt-Anchor" href="#登录选项"></a> 登录选项</h2><p>常用登录选项：</p><ul><li><code>-N</code>：只连接远程主机，不打开远程 shell</li><li><code>-T</code>：不分配 TTY</li><li><code>-f</code>：后台运行</li><li><code>-p &lt;端口&gt;</code>：指定端口号</li><li><code>-l &lt;登录名&gt;</code>：指定登录名</li><li><code>-q</code>：安静模式</li><li><code>-v</code>：详细模式</li><li><code>-b &lt;绑定地址:&gt;</code>：指定绑定地址作为源地址</li><li><code>-g</code>：远程主机在本地的转发端口</li><li><code>-4</code>：只使用 ipv4</li><li><code>-6</code>：只使用 ipv6</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
